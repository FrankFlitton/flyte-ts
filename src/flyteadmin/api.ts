// @ts-ignore
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * flyteidl/service/admin.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import "node-self";
import "cross-fetch/polyfill";
// import "./fetch-polyfill.js";
import * as url from "url";
import { fetch as crossFetch } from "cross-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration | undefined;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = crossFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name!: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * Specifies metadata around an aborted workflow execution.
 * @export
 * @interface AdminAbortMetadata
 */
export interface AdminAbortMetadata {
  /**
   * In the case of a user-specified abort, this will pass along the user-supplied cause.
   * @type {string}
   * @memberof AdminAbortMetadata
   */
  cause?: string;
  /**
   *
   * @type {string}
   * @memberof AdminAbortMetadata
   */
  principal?: string;
}

/**
 * Annotation values to be applied to an execution resource. In the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined to specify how to merge annotations defined at registration and execution time.
 * @export
 * @interface AdminAnnotations
 */
export interface AdminAnnotations {
  /**
   * Map of custom annotations to be applied to the execution resource.
   * @type {{ [key: string]: string; }}
   * @memberof AdminAnnotations
   */
  values?: { [key: string]: string };
}

/**
 * Defines permissions associated with executions created by this launch plan spec. Use either of these roles when they have permissions required by your workflow execution. Deprecated.
 * @export
 * @interface AdminAuth
 */
export interface AdminAuth {
  /**
   * Defines an optional iam role which will be used for tasks run in executions created with this launch plan.
   * @type {string}
   * @memberof AdminAuth
   */
  assumableIamRole?: string;
  /**
   * Defines an optional kubernetes service account which will be used for tasks run in executions created with this launch plan.
   * @type {string}
   * @memberof AdminAuth
   */
  kubernetesServiceAccount?: string;
}

/**
 * Defines permissions associated with executions created by this launch plan spec. Use either of these roles when they have permissions required by your workflow execution. Deprecated.
 * @export
 * @interface AdminAuthRole
 */
export interface AdminAuthRole {
  /**
   * Defines an optional iam role which will be used for tasks run in executions created with this launch plan.
   * @type {string}
   * @memberof AdminAuthRole
   */
  assumableIamRole?: string;
  /**
   * Defines an optional kubernetes service account which will be used for tasks run in executions created with this launch plan.
   * @type {string}
   * @memberof AdminAuthRole
   */
  kubernetesServiceAccount?: string;
}

/**
 * Encapsulates specifications for routing an execution onto a specific cluster.
 * @export
 * @interface AdminClusterAssignment
 */
export interface AdminClusterAssignment {
  /**
   *
   * @type {string}
   * @memberof AdminClusterAssignment
   */
  clusterPoolName?: string;
}

/**
 *
 * @export
 * @interface AdminClusterResourceAttributes
 */
export interface AdminClusterResourceAttributes {
  /**
   * Custom resource attributes which will be applied in cluster resource creation (e.g. quotas). Map keys are the *case-sensitive* names of variables in templatized resource files. Map values should be the custom values which get substituted during resource creation.
   * @type {{ [key: string]: string; }}
   * @memberof AdminClusterResourceAttributes
   */
  attributes?: { [key: string]: string };
}

/**
 * Options for schedules to run according to a cron expression.
 * @export
 * @interface AdminCronSchedule
 */
export interface AdminCronSchedule {
  /**
   *
   * @type {string}
   * @memberof AdminCronSchedule
   */
  schedule?: string;
  /**
   *
   * @type {string}
   * @memberof AdminCronSchedule
   */
  offset?: string;
}

/**
 * Full user description with formatting preserved. This can be rendered by clients, such as the console or command line tools with in-tact formatting.
 * @export
 * @interface AdminDescription
 */
export interface AdminDescription {
  /**
   *
   * @type {string}
   * @memberof AdminDescription
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof AdminDescription
   */
  uri?: string;
  /**
   *
   * @type {AdminDescriptionFormat}
   * @memberof AdminDescription
   */
  format?: AdminDescriptionFormat;
  /**
   *
   * @type {string}
   * @memberof AdminDescription
   */
  iconLink?: string;
}

/**
 * DescriptionEntity contains detailed description for the task/workflow. Documentation could provide insight into the algorithms, business use case, etc.
 * @export
 * @interface AdminDescriptionEntity
 */
export interface AdminDescriptionEntity {
  /**
   * id represents the unique identifier of the description entity.
   * @type {CoreIdentifier}
   * @memberof AdminDescriptionEntity
   */
  id?: CoreIdentifier;
  /**
   * One-liner overview of the entity.
   * @type {string}
   * @memberof AdminDescriptionEntity
   */
  shortDescription?: string;
  /**
   * Full user description with formatting preserved.
   * @type {AdminDescription}
   * @memberof AdminDescriptionEntity
   */
  longDescription?: AdminDescription;
  /**
   * Optional link to source code used to define this entity.
   * @type {AdminSourceCode}
   * @memberof AdminDescriptionEntity
   */
  sourceCode?: AdminSourceCode;
  /**
   * User-specified tags. These are arbitrary and can be used for searching filtering and discovering tasks.
   * @type {Array<string>}
   * @memberof AdminDescriptionEntity
   */
  tags?: Array<string>;
}

/**
 *
 * @export
 * @interface AdminDescriptionEntityList
 */
export interface AdminDescriptionEntityList {
  /**
   * A list of DescriptionEntities returned based on the request.
   * @type {Array<AdminDescriptionEntity>}
   * @memberof AdminDescriptionEntityList
   */
  descriptionEntities?: Array<AdminDescriptionEntity>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminDescriptionEntityList
   */
  token?: string;
}

/**
 * - DESCRIPTION_FORMAT_RST: python default documentation - comments is rst
 * @export
 * @enum {string}
 */
export enum AdminDescriptionFormat {
  UNKNOWN = <any>"DESCRIPTION_FORMAT_UNKNOWN",
  MARKDOWN = <any>"DESCRIPTION_FORMAT_MARKDOWN",
  HTML = <any>"DESCRIPTION_FORMAT_HTML",
  RST = <any>"DESCRIPTION_FORMAT_RST",
}

/**
 * Namespace within a project commonly used to differentiate between different service instances. e.g. \"production\", \"development\", etc.
 * @export
 * @interface AdminDomain
 */
export interface AdminDomain {
  /**
   * Globally unique domain name.
   * @type {string}
   * @memberof AdminDomain
   */
  id?: string;
  /**
   * Display name.
   * @type {string}
   * @memberof AdminDomain
   */
  name?: string;
}

/**
 * Defines an email notification specification.
 * @export
 * @interface AdminEmailNotification
 */
export interface AdminEmailNotification {
  /**
   *
   * @type {Array<string>}
   * @memberof AdminEmailNotification
   */
  recipientsEmail?: Array<string>;
}

/**
 * Environment variable values to be applied to an execution resource. In the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined to specify how to merge environment variables defined at registration and execution time.
 * @export
 * @interface AdminEnvs
 */
export interface AdminEnvs {
  /**
   * Map of custom environment variables to be applied to the execution resource.
   * @type {Array<CoreKeyValuePair>}
   * @memberof AdminEnvs
   */
  values?: Array<CoreKeyValuePair>;
}

/**
 * A workflow execution represents an instantiated workflow, including all inputs and additional metadata as well as computed results included state, outputs, and duration-based attributes. Used as a response object used in Get and List execution requests.
 * @export
 * @interface AdminExecution
 */
export interface AdminExecution {
  /**
   * Unique identifier of the workflow execution.
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof AdminExecution
   */
  id?: CoreWorkflowExecutionIdentifier;
  /**
   * User-provided configuration and inputs for launching the execution.
   * @type {AdminExecutionSpec}
   * @memberof AdminExecution
   */
  spec?: AdminExecutionSpec;
  /**
   * Execution results.
   * @type {AdminExecutionClosure}
   * @memberof AdminExecution
   */
  closure?: AdminExecutionClosure;
}

/**
 *
 * @export
 * @interface AdminExecutionClosure
 */
export interface AdminExecutionClosure {
  /**
   * Output URI in the case of a successful execution. DEPRECATED. Use GetExecutionData to fetch output data instead.
   * @type {AdminLiteralMapBlob}
   * @memberof AdminExecutionClosure
   */
  outputs?: AdminLiteralMapBlob;
  /**
   * Error information in the case of a failed execution.
   * @type {CoreExecutionError}
   * @memberof AdminExecutionClosure
   */
  error?: CoreExecutionError;
  /**
   * In the case of a user-specified abort, this will pass along the user-supplied cause.
   * @type {string}
   * @memberof AdminExecutionClosure
   */
  abortCause?: string;
  /**
   * In the case of a user-specified abort, this will pass along the user and their supplied cause.
   * @type {AdminAbortMetadata}
   * @memberof AdminExecutionClosure
   */
  abortMetadata?: AdminAbortMetadata;
  /**
   * Raw output data produced by this execution. DEPRECATED. Use GetExecutionData to fetch output data instead.
   * @type {CoreLiteralMap}
   * @memberof AdminExecutionClosure
   */
  outputData?: CoreLiteralMap;
  /**
   *
   * @type {CoreLiteralMap}
   * @memberof AdminExecutionClosure
   */
  computedInputs?: CoreLiteralMap;
  /**
   * Most recent recorded phase for the execution.
   * @type {CoreWorkflowExecutionPhase}
   * @memberof AdminExecutionClosure
   */
  phase?: CoreWorkflowExecutionPhase;
  /**
   * Reported time at which the execution began running.
   * @type {Date}
   * @memberof AdminExecutionClosure
   */
  startedAt?: Date;
  /**
   * The amount of time the execution spent running.
   * @type {string}
   * @memberof AdminExecutionClosure
   */
  duration?: string;
  /**
   * Reported time at which the execution was created.
   * @type {Date}
   * @memberof AdminExecutionClosure
   */
  createdAt?: Date;
  /**
   * Reported time at which the execution was last updated.
   * @type {Date}
   * @memberof AdminExecutionClosure
   */
  updatedAt?: Date;
  /**
   * The notification settings to use after merging the CreateExecutionRequest and the launch plan notification settings. An execution launched with notifications will always prefer that definition to notifications defined statically in a launch plan.
   * @type {Array<AdminNotification>}
   * @memberof AdminExecutionClosure
   */
  notifications?: Array<AdminNotification>;
  /**
   * Identifies the workflow definition for this execution.
   * @type {CoreIdentifier}
   * @memberof AdminExecutionClosure
   */
  workflowId?: CoreIdentifier;
  /**
   *
   * @type {AdminExecutionStateChangeDetails}
   * @memberof AdminExecutionClosure
   */
  stateChangeDetails?: AdminExecutionStateChangeDetails;
}

/**
 *
 * @export
 * @interface AdminExecutionClusterLabel
 */
export interface AdminExecutionClusterLabel {
  /**
   *
   * @type {string}
   * @memberof AdminExecutionClusterLabel
   */
  value?: string;
}

/**
 * Request to launch an execution with the given project, domain and optionally-assigned name.
 * @export
 * @interface AdminExecutionCreateRequest
 */
export interface AdminExecutionCreateRequest {
  /**
   *
   * @type {string}
   * @memberof AdminExecutionCreateRequest
   */
  project?: string;
  /**
   *
   * @type {string}
   * @memberof AdminExecutionCreateRequest
   */
  domain?: string;
  /**
   *
   * @type {string}
   * @memberof AdminExecutionCreateRequest
   */
  name?: string;
  /**
   *
   * @type {AdminExecutionSpec}
   * @memberof AdminExecutionCreateRequest
   */
  spec?: AdminExecutionSpec;
  /**
   *
   * @type {CoreLiteralMap}
   * @memberof AdminExecutionCreateRequest
   */
  inputs?: CoreLiteralMap;
}

/**
 * The unique identifier for a successfully created execution. If the name was *not* specified in the create request, this identifier will include a generated name.
 * @export
 * @interface AdminExecutionCreateResponse
 */
export interface AdminExecutionCreateResponse {
  /**
   *
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof AdminExecutionCreateResponse
   */
  id?: CoreWorkflowExecutionIdentifier;
}

/**
 *
 * @export
 * @interface AdminExecutionList
 */
export interface AdminExecutionList {
  /**
   *
   * @type {Array<AdminExecution>}
   * @memberof AdminExecutionList
   */
  executions?: Array<AdminExecution>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminExecutionList
   */
  token?: string;
}

/**
 * Represents attributes about an execution which are not required to launch the execution but are useful to record. These attributes are assigned at launch time and do not change.
 * @export
 * @interface AdminExecutionMetadata
 */
export interface AdminExecutionMetadata {
  /**
   *
   * @type {ExecutionMetadataExecutionMode}
   * @memberof AdminExecutionMetadata
   */
  mode?: ExecutionMetadataExecutionMode;
  /**
   * Identifier of the entity that triggered this execution. For systems using back-end authentication any value set here will be discarded in favor of the authenticated user context.
   * @type {string}
   * @memberof AdminExecutionMetadata
   */
  principal?: string;
  /**
   * Indicates the nestedness of this execution. If a user launches a workflow execution, the default nesting is 0. If this execution further launches a workflow (child workflow), the nesting level is incremented by 0 => 1 Generally, if workflow at nesting level k launches a workflow then the child workflow will have nesting = k + 1.
   * @type {number}
   * @memberof AdminExecutionMetadata
   */
  nesting?: number;
  /**
   * For scheduled executions, the requested time for execution for this specific schedule invocation.
   * @type {Date}
   * @memberof AdminExecutionMetadata
   */
  scheduledAt?: Date;
  /**
   *
   * @type {CoreNodeExecutionIdentifier}
   * @memberof AdminExecutionMetadata
   */
  parentNodeExecution?: CoreNodeExecutionIdentifier;
  /**
   * Optional, a reference workflow execution related to this execution. In the case of a relaunch, this references the original workflow execution.
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof AdminExecutionMetadata
   */
  referenceExecution?: CoreWorkflowExecutionIdentifier;
  /**
   * Optional, platform-specific metadata about the execution. In this the future this may be gated behind an ACL or some sort of authorization.
   * @type {AdminSystemMetadata}
   * @memberof AdminExecutionMetadata
   */
  systemMetadata?: AdminSystemMetadata;
}

/**
 *
 * @export
 * @interface AdminExecutionQueueAttributes
 */
export interface AdminExecutionQueueAttributes {
  /**
   * Tags used for assigning execution queues for tasks defined within this project.
   * @type {Array<string>}
   * @memberof AdminExecutionQueueAttributes
   */
  tags?: Array<string>;
}

/**
 * Request to recover the referenced execution.
 * @export
 * @interface AdminExecutionRecoverRequest
 */
export interface AdminExecutionRecoverRequest {
  /**
   * Identifier of the workflow execution to recover.
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof AdminExecutionRecoverRequest
   */
  id?: CoreWorkflowExecutionIdentifier;
  /**
   *
   * @type {string}
   * @memberof AdminExecutionRecoverRequest
   */
  name?: string;
  /**
   * Additional metadata which will be used to overwrite any metadata in the reference execution when triggering a recovery execution.
   * @type {AdminExecutionMetadata}
   * @memberof AdminExecutionRecoverRequest
   */
  metadata?: AdminExecutionMetadata;
}

/**
 * Request to relaunch the referenced execution.
 * @export
 * @interface AdminExecutionRelaunchRequest
 */
export interface AdminExecutionRelaunchRequest {
  /**
   *
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof AdminExecutionRelaunchRequest
   */
  id?: CoreWorkflowExecutionIdentifier;
  /**
   *
   * @type {string}
   * @memberof AdminExecutionRelaunchRequest
   */
  name?: string;
  /**
   * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
   * @type {boolean}
   * @memberof AdminExecutionRelaunchRequest
   */
  overwriteCache?: boolean;
}

/**
 * An ExecutionSpec encompasses all data used to launch this execution. The Spec does not change over the lifetime of an execution as it progresses across phase changes.
 * @export
 * @interface AdminExecutionSpec
 */
export interface AdminExecutionSpec {
  /**
   *
   * @type {CoreIdentifier}
   * @memberof AdminExecutionSpec
   */
  launchPlan?: CoreIdentifier;
  /**
   *
   * @type {CoreLiteralMap}
   * @memberof AdminExecutionSpec
   */
  inputs?: CoreLiteralMap;
  /**
   *
   * @type {AdminExecutionMetadata}
   * @memberof AdminExecutionSpec
   */
  metadata?: AdminExecutionMetadata;
  /**
   * List of notifications based on Execution status transitions When this list is not empty it is used rather than any notifications defined in the referenced launch plan. When this list is empty, the notifications defined for the launch plan will be applied.
   * @type {AdminNotificationList}
   * @memberof AdminExecutionSpec
   */
  notifications?: AdminNotificationList;
  /**
   * This should be set to true if all notifications are intended to be disabled for this execution.
   * @type {boolean}
   * @memberof AdminExecutionSpec
   */
  disableAll?: boolean;
  /**
   * Labels to apply to the execution resource.
   * @type {AdminLabels}
   * @memberof AdminExecutionSpec
   */
  labels?: AdminLabels;
  /**
   * Annotations to apply to the execution resource.
   * @type {AdminAnnotations}
   * @memberof AdminExecutionSpec
   */
  annotations?: AdminAnnotations;
  /**
   * Optional: security context override to apply this execution.
   * @type {CoreSecurityContext}
   * @memberof AdminExecutionSpec
   */
  securityContext?: CoreSecurityContext;
  /**
   * Optional: auth override to apply this execution.
   * @type {AdminAuthRole}
   * @memberof AdminExecutionSpec
   */
  authRole?: AdminAuthRole;
  /**
   * Indicates the runtime priority of the execution.
   * @type {CoreQualityOfService}
   * @memberof AdminExecutionSpec
   */
  qualityOfService?: CoreQualityOfService;
  /**
   * Controls the maximum number of task nodes that can be run in parallel for the entire workflow. This is useful to achieve fairness. Note: MapTasks are regarded as one unit, and parallelism/concurrency of MapTasks is independent from this.
   * @type {number}
   * @memberof AdminExecutionSpec
   */
  maxParallelism?: number;
  /**
   *
   * @type {AdminRawOutputDataConfig}
   * @memberof AdminExecutionSpec
   */
  rawOutputDataConfig?: AdminRawOutputDataConfig;
  /**
   * Controls how to select an available cluster on which this execution should run.
   * @type {AdminClusterAssignment}
   * @memberof AdminExecutionSpec
   */
  clusterAssignment?: AdminClusterAssignment;
  /**
   * Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.
   * @type {boolean}
   * @memberof AdminExecutionSpec
   */
  interruptible?: boolean;
  /**
   * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
   * @type {boolean}
   * @memberof AdminExecutionSpec
   */
  overwriteCache?: boolean;
  /**
   * Environment variables to be set for the execution.
   * @type {AdminEnvs}
   * @memberof AdminExecutionSpec
   */
  envs?: AdminEnvs;
  /**
   * Tags to be set for the execution.
   * @type {Array<string>}
   * @memberof AdminExecutionSpec
   */
  tags?: Array<string>;
}

/**
 * The state of the execution is used to control its visibility in the UI/CLI.   - EXECUTION_ACTIVE: By default, all executions are considered active.  - EXECUTION_ARCHIVED: Archived executions are no longer visible in the UI.
 * @export
 * @enum {string}
 */
export enum AdminExecutionState {
  ACTIVE = <any>"EXECUTION_ACTIVE",
  ARCHIVED = <any>"EXECUTION_ARCHIVED",
}

/**
 *
 * @export
 * @interface AdminExecutionStateChangeDetails
 */
export interface AdminExecutionStateChangeDetails {
  /**
   * The state of the execution is used to control its visibility in the UI/CLI.
   * @type {AdminExecutionState}
   * @memberof AdminExecutionStateChangeDetails
   */
  state?: AdminExecutionState;
  /**
   * This timestamp represents when the state changed.
   * @type {Date}
   * @memberof AdminExecutionStateChangeDetails
   */
  occurredAt?: Date;
  /**
   *
   * @type {string}
   * @memberof AdminExecutionStateChangeDetails
   */
  principal?: string;
}

/**
 * Request to terminate an in-progress execution.  This action is irreversible. If an execution is already terminated, this request will simply be a no-op. This request will fail if it references a non-existent execution. If the request succeeds the phase \"ABORTED\" will be recorded for the termination with the optional cause added to the output_result.
 * @export
 * @interface AdminExecutionTerminateRequest
 */
export interface AdminExecutionTerminateRequest {
  /**
   * Uniquely identifies the individual workflow execution to be terminated.
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof AdminExecutionTerminateRequest
   */
  id?: CoreWorkflowExecutionIdentifier;
  /**
   * Optional reason for aborting.
   * @type {string}
   * @memberof AdminExecutionTerminateRequest
   */
  cause?: string;
}

/**
 *
 * @export
 * @interface AdminExecutionTerminateResponse
 */
export interface AdminExecutionTerminateResponse {}

/**
 *
 * @export
 * @interface AdminExecutionUpdateRequest
 */
export interface AdminExecutionUpdateRequest {
  /**
   *
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof AdminExecutionUpdateRequest
   */
  id?: CoreWorkflowExecutionIdentifier;
  /**
   *
   * @type {AdminExecutionState}
   * @memberof AdminExecutionUpdateRequest
   */
  state?: AdminExecutionState;
}

/**
 *
 * @export
 * @interface AdminExecutionUpdateResponse
 */
export interface AdminExecutionUpdateResponse {}

/**
 * Option for schedules run at a certain frequency e.g. every 2 minutes.
 * @export
 * @interface AdminFixedRate
 */
export interface AdminFixedRate {
  /**
   *
   * @type {number}
   * @memberof AdminFixedRate
   */
  value?: number;
  /**
   *
   * @type {AdminFixedRateUnit}
   * @memberof AdminFixedRate
   */
  unit?: AdminFixedRateUnit;
}

/**
 * Represents a frequency at which to run a schedule.
 * @export
 * @enum {string}
 */
export enum AdminFixedRateUnit {
  MINUTE = <any>"MINUTE",
  HOUR = <any>"HOUR",
  DAY = <any>"DAY",
}

/**
 * These URLs are returned as part of node and task execution data requests.
 * @export
 * @interface AdminFlyteURLs
 */
export interface AdminFlyteURLs {
  /**
   *
   * @type {string}
   * @memberof AdminFlyteURLs
   */
  inputs?: string;
  /**
   *
   * @type {string}
   * @memberof AdminFlyteURLs
   */
  outputs?: string;
  /**
   *
   * @type {string}
   * @memberof AdminFlyteURLs
   */
  deck?: string;
}

/**
 *
 * @export
 * @interface AdminGetVersionResponse
 */
export interface AdminGetVersionResponse {
  /**
   *
   * @type {AdminVersion}
   * @memberof AdminGetVersionResponse
   */
  controlPlaneVersion?: AdminVersion;
}

/**
 * Label values to be applied to an execution resource. In the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined to specify how to merge labels defined at registration and execution time.
 * @export
 * @interface AdminLabels
 */
export interface AdminLabels {
  /**
   * Map of custom labels to be applied to the execution resource.
   * @type {{ [key: string]: string; }}
   * @memberof AdminLabels
   */
  values?: { [key: string]: string };
}

/**
 * A LaunchPlan provides the capability to templatize workflow executions. Launch plans simplify associating one or more schedules, inputs and notifications with your workflows. Launch plans can be shared and used to trigger executions with predefined inputs even when a workflow definition doesn't necessarily have a default value for said input.
 * @export
 * @interface AdminLaunchPlan
 */
export interface AdminLaunchPlan {
  /**
   * Uniquely identifies a launch plan entity.
   * @type {CoreIdentifier}
   * @memberof AdminLaunchPlan
   */
  id?: CoreIdentifier;
  /**
   * User-provided launch plan details, including reference workflow, inputs and other metadata.
   * @type {AdminLaunchPlanSpec}
   * @memberof AdminLaunchPlan
   */
  spec?: AdminLaunchPlanSpec;
  /**
   * Values computed by the flyte platform after launch plan registration.
   * @type {AdminLaunchPlanClosure}
   * @memberof AdminLaunchPlan
   */
  closure?: AdminLaunchPlanClosure;
}

/**
 * Values computed by the flyte platform after launch plan registration. These include expected_inputs required to be present in a CreateExecutionRequest to launch the reference workflow as well timestamp values associated with the launch plan.
 * @export
 * @interface AdminLaunchPlanClosure
 */
export interface AdminLaunchPlanClosure {
  /**
   * Indicate the Launch plan state.
   * @type {AdminLaunchPlanState}
   * @memberof AdminLaunchPlanClosure
   */
  state?: AdminLaunchPlanState;
  /**
   *
   * @type {CoreParameterMap}
   * @memberof AdminLaunchPlanClosure
   */
  expectedInputs?: CoreParameterMap;
  /**
   *
   * @type {CoreVariableMap}
   * @memberof AdminLaunchPlanClosure
   */
  expectedOutputs?: CoreVariableMap;
  /**
   * Time at which the launch plan was created.
   * @type {Date}
   * @memberof AdminLaunchPlanClosure
   */
  createdAt?: Date;
  /**
   * Time at which the launch plan was last updated.
   * @type {Date}
   * @memberof AdminLaunchPlanClosure
   */
  updatedAt?: Date;
}

/**
 * Request to register a launch plan. The included LaunchPlanSpec may have a complete or incomplete set of inputs required to launch a workflow execution. By default all launch plans are registered in state INACTIVE. If you wish to set the state to ACTIVE, you must submit a LaunchPlanUpdateRequest, after you have successfully created a launch plan.
 * @export
 * @interface AdminLaunchPlanCreateRequest
 */
export interface AdminLaunchPlanCreateRequest {
  /**
   * Uniquely identifies a launch plan entity.
   * @type {CoreIdentifier}
   * @memberof AdminLaunchPlanCreateRequest
   */
  id?: CoreIdentifier;
  /**
   * User-provided launch plan details, including reference workflow, inputs and other metadata.
   * @type {AdminLaunchPlanSpec}
   * @memberof AdminLaunchPlanCreateRequest
   */
  spec?: AdminLaunchPlanSpec;
}

/**
 *
 * @export
 * @interface AdminLaunchPlanCreateResponse
 */
export interface AdminLaunchPlanCreateResponse {}

/**
 *
 * @export
 * @interface AdminLaunchPlanList
 */
export interface AdminLaunchPlanList {
  /**
   *
   * @type {Array<AdminLaunchPlan>}
   * @memberof AdminLaunchPlanList
   */
  launchPlans?: Array<AdminLaunchPlan>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminLaunchPlanList
   */
  token?: string;
}

/**
 * Additional launch plan attributes included in the LaunchPlanSpec not strictly required to launch the reference workflow.
 * @export
 * @interface AdminLaunchPlanMetadata
 */
export interface AdminLaunchPlanMetadata {
  /**
   *
   * @type {AdminSchedule}
   * @memberof AdminLaunchPlanMetadata
   */
  schedule?: AdminSchedule;
  /**
   *
   * @type {Array<AdminNotification>}
   * @memberof AdminLaunchPlanMetadata
   */
  notifications?: Array<AdminNotification>;
}

/**
 * User-provided launch plan definition and configuration values.
 * @export
 * @interface AdminLaunchPlanSpec
 */
export interface AdminLaunchPlanSpec {
  /**
   *
   * @type {CoreIdentifier}
   * @memberof AdminLaunchPlanSpec
   */
  workflowId?: CoreIdentifier;
  /**
   *
   * @type {AdminLaunchPlanMetadata}
   * @memberof AdminLaunchPlanSpec
   */
  entityMetadata?: AdminLaunchPlanMetadata;
  /**
   * Input values to be passed for the execution. These can be overridden when an execution is created with this launch plan.
   * @type {CoreParameterMap}
   * @memberof AdminLaunchPlanSpec
   */
  defaultInputs?: CoreParameterMap;
  /**
   * Fixed, non-overridable inputs for the Launch Plan. These can not be overridden when an execution is created with this launch plan.
   * @type {CoreLiteralMap}
   * @memberof AdminLaunchPlanSpec
   */
  fixedInputs?: CoreLiteralMap;
  /**
   *
   * @type {string}
   * @memberof AdminLaunchPlanSpec
   */
  role?: string;
  /**
   * Custom labels to be applied to the execution resource.
   * @type {AdminLabels}
   * @memberof AdminLaunchPlanSpec
   */
  labels?: AdminLabels;
  /**
   * Custom annotations to be applied to the execution resource.
   * @type {AdminAnnotations}
   * @memberof AdminLaunchPlanSpec
   */
  annotations?: AdminAnnotations;
  /**
   * Indicates the permission associated with workflow executions triggered with this launch plan.
   * @type {AdminAuth}
   * @memberof AdminLaunchPlanSpec
   */
  auth?: AdminAuth;
  /**
   *
   * @type {AdminAuthRole}
   * @memberof AdminLaunchPlanSpec
   */
  authRole?: AdminAuthRole;
  /**
   *
   * @type {CoreSecurityContext}
   * @memberof AdminLaunchPlanSpec
   */
  securityContext?: CoreSecurityContext;
  /**
   * Indicates the runtime priority of the execution.
   * @type {CoreQualityOfService}
   * @memberof AdminLaunchPlanSpec
   */
  qualityOfService?: CoreQualityOfService;
  /**
   * Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.).
   * @type {AdminRawOutputDataConfig}
   * @memberof AdminLaunchPlanSpec
   */
  rawOutputDataConfig?: AdminRawOutputDataConfig;
  /**
   * Controls the maximum number of tasknodes that can be run in parallel for the entire workflow. This is useful to achieve fairness. Note: MapTasks are regarded as one unit, and parallelism/concurrency of MapTasks is independent from this.
   * @type {number}
   * @memberof AdminLaunchPlanSpec
   */
  maxParallelism?: number;
  /**
   * Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.
   * @type {boolean}
   * @memberof AdminLaunchPlanSpec
   */
  interruptible?: boolean;
  /**
   * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
   * @type {boolean}
   * @memberof AdminLaunchPlanSpec
   */
  overwriteCache?: boolean;
  /**
   * Environment variables to be set for the execution.
   * @type {AdminEnvs}
   * @memberof AdminLaunchPlanSpec
   */
  envs?: AdminEnvs;
}

/**
 * By default any launch plan regardless of state can be used to launch a workflow execution. However, at most one version of a launch plan (e.g. a NamedEntityIdentifier set of shared project, domain and name values) can be active at a time in regards to *schedules*. That is, at most one schedule in a NamedEntityIdentifier group will be observed and trigger executions at a defined cadence.
 * @export
 * @enum {string}
 */
export enum AdminLaunchPlanState {
  INACTIVE = <any>"INACTIVE",
  ACTIVE = <any>"ACTIVE",
}

/**
 *
 * @export
 * @interface AdminLaunchPlanUpdateRequest
 */
export interface AdminLaunchPlanUpdateRequest {
  /**
   * Identifier of launch plan for which to change state. +required.
   * @type {CoreIdentifier}
   * @memberof AdminLaunchPlanUpdateRequest
   */
  id?: CoreIdentifier;
  /**
   * Desired state to apply to the launch plan. +required.
   * @type {AdminLaunchPlanState}
   * @memberof AdminLaunchPlanUpdateRequest
   */
  state?: AdminLaunchPlanState;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminLaunchPlanUpdateResponse
 */
export interface AdminLaunchPlanUpdateResponse {}

/**
 *
 * @export
 * @interface AdminListMatchableAttributesResponse
 */
export interface AdminListMatchableAttributesResponse {
  /**
   *
   * @type {Array<AdminMatchableAttributesConfiguration>}
   * @memberof AdminListMatchableAttributesResponse
   */
  configurations?: Array<AdminMatchableAttributesConfiguration>;
}

/**
 *
 * @export
 * @interface AdminLiteralMapBlob
 */
export interface AdminLiteralMapBlob {
  /**
   *
   * @type {CoreLiteralMap}
   * @memberof AdminLiteralMapBlob
   */
  values?: CoreLiteralMap;
  /**
   *
   * @type {string}
   * @memberof AdminLiteralMapBlob
   */
  uri?: string;
}

/**
 * Represents a custom set of attributes applied for either a domain; a domain and project; or domain, project and workflow name. These are used to override system level defaults for kubernetes cluster resource management, default execution values, and more all across different levels of specificity.
 * @export
 * @interface AdminMatchableAttributesConfiguration
 */
export interface AdminMatchableAttributesConfiguration {
  /**
   *
   * @type {AdminMatchingAttributes}
   * @memberof AdminMatchableAttributesConfiguration
   */
  attributes?: AdminMatchingAttributes;
  /**
   *
   * @type {string}
   * @memberof AdminMatchableAttributesConfiguration
   */
  domain?: string;
  /**
   *
   * @type {string}
   * @memberof AdminMatchableAttributesConfiguration
   */
  project?: string;
  /**
   *
   * @type {string}
   * @memberof AdminMatchableAttributesConfiguration
   */
  workflow?: string;
  /**
   *
   * @type {string}
   * @memberof AdminMatchableAttributesConfiguration
   */
  launchPlan?: string;
}

/**
 * Defines a resource that can be configured by customizable Project-, ProjectDomain- or WorkflowAttributes based on matching tags.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
 * @export
 * @enum {string}
 */
export enum AdminMatchableResource {
  TASKRESOURCE = <any>"TASK_RESOURCE",
  CLUSTERRESOURCE = <any>"CLUSTER_RESOURCE",
  EXECUTIONQUEUE = <any>"EXECUTION_QUEUE",
  EXECUTIONCLUSTERLABEL = <any>"EXECUTION_CLUSTER_LABEL",
  QUALITYOFSERVICESPECIFICATION = <any>"QUALITY_OF_SERVICE_SPECIFICATION",
  PLUGINOVERRIDE = <any>"PLUGIN_OVERRIDE",
  WORKFLOWEXECUTIONCONFIG = <any>"WORKFLOW_EXECUTION_CONFIG",
  CLUSTERASSIGNMENT = <any>"CLUSTER_ASSIGNMENT",
}

/**
 * Generic container for encapsulating all types of the above attributes messages.
 * @export
 * @interface AdminMatchingAttributes
 */
export interface AdminMatchingAttributes {
  /**
   *
   * @type {AdminTaskResourceAttributes}
   * @memberof AdminMatchingAttributes
   */
  taskResourceAttributes?: AdminTaskResourceAttributes;
  /**
   *
   * @type {AdminClusterResourceAttributes}
   * @memberof AdminMatchingAttributes
   */
  clusterResourceAttributes?: AdminClusterResourceAttributes;
  /**
   *
   * @type {AdminExecutionQueueAttributes}
   * @memberof AdminMatchingAttributes
   */
  executionQueueAttributes?: AdminExecutionQueueAttributes;
  /**
   *
   * @type {AdminExecutionClusterLabel}
   * @memberof AdminMatchingAttributes
   */
  executionClusterLabel?: AdminExecutionClusterLabel;
  /**
   *
   * @type {CoreQualityOfService}
   * @memberof AdminMatchingAttributes
   */
  qualityOfService?: CoreQualityOfService;
  /**
   *
   * @type {AdminPluginOverrides}
   * @memberof AdminMatchingAttributes
   */
  pluginOverrides?: AdminPluginOverrides;
  /**
   *
   * @type {AdminWorkflowExecutionConfig}
   * @memberof AdminMatchingAttributes
   */
  workflowExecutionConfig?: AdminWorkflowExecutionConfig;
  /**
   *
   * @type {AdminClusterAssignment}
   * @memberof AdminMatchingAttributes
   */
  clusterAssignment?: AdminClusterAssignment;
}

/**
 * Encapsulates information common to a NamedEntity, a Flyte resource such as a task, workflow or launch plan. A NamedEntity is exclusively identified by its resource type and identifier.
 * @export
 * @interface AdminNamedEntity
 */
export interface AdminNamedEntity {
  /**
   * Resource type of the named entity. One of Task, Workflow or LaunchPlan.
   * @type {CoreResourceType}
   * @memberof AdminNamedEntity
   */
  resourceType?: CoreResourceType;
  /**
   *
   * @type {AdminNamedEntityIdentifier}
   * @memberof AdminNamedEntity
   */
  id?: AdminNamedEntityIdentifier;
  /**
   * Additional metadata around a named entity.
   * @type {AdminNamedEntityMetadata}
   * @memberof AdminNamedEntity
   */
  metadata?: AdminNamedEntityMetadata;
}

/**
 * Encapsulation of fields that identifies a Flyte resource. A Flyte resource can be a task, workflow or launch plan. A resource can internally have multiple versions and is uniquely identified by project, domain, and name.
 * @export
 * @interface AdminNamedEntityIdentifier
 */
export interface AdminNamedEntityIdentifier {
  /**
   * Name of the project the resource belongs to.
   * @type {string}
   * @memberof AdminNamedEntityIdentifier
   */
  project?: string;
  /**
   * Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @type {string}
   * @memberof AdminNamedEntityIdentifier
   */
  domain?: string;
  /**
   *
   * @type {string}
   * @memberof AdminNamedEntityIdentifier
   */
  name?: string;
}

/**
 * Represents a list of NamedEntityIdentifiers.
 * @export
 * @interface AdminNamedEntityIdentifierList
 */
export interface AdminNamedEntityIdentifierList {
  /**
   * A list of identifiers.
   * @type {Array<AdminNamedEntityIdentifier>}
   * @memberof AdminNamedEntityIdentifierList
   */
  entities?: Array<AdminNamedEntityIdentifier>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminNamedEntityIdentifierList
   */
  token?: string;
}

/**
 * Represents a list of NamedEntityIdentifiers.
 * @export
 * @interface AdminNamedEntityList
 */
export interface AdminNamedEntityList {
  /**
   *
   * @type {Array<AdminNamedEntity>}
   * @memberof AdminNamedEntityList
   */
  entities?: Array<AdminNamedEntity>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminNamedEntityList
   */
  token?: string;
}

/**
 * Additional metadata around a named entity.
 * @export
 * @interface AdminNamedEntityMetadata
 */
export interface AdminNamedEntityMetadata {
  /**
   *
   * @type {string}
   * @memberof AdminNamedEntityMetadata
   */
  description?: string;
  /**
   * Shared state across all version of the entity At this point in time, only workflow entities can have their state archived.
   * @type {AdminNamedEntityState}
   * @memberof AdminNamedEntityMetadata
   */
  state?: AdminNamedEntityState;
}

/**
 * The status of the named entity is used to control its visibility in the UI.   - NAMED_ENTITY_ACTIVE: By default, all named entities are considered active and under development.  - NAMED_ENTITY_ARCHIVED: Archived named entities are no longer visible in the UI.  - SYSTEM_GENERATED: System generated entities that aren't explicitly created or managed by a user.
 * @export
 * @enum {string}
 */
export enum AdminNamedEntityState {
  NAMEDENTITYACTIVE = <any>"NAMED_ENTITY_ACTIVE",
  NAMEDENTITYARCHIVED = <any>"NAMED_ENTITY_ARCHIVED",
  SYSTEMGENERATED = <any>"SYSTEM_GENERATED",
}

/**
 * Request to set the referenced named entity state to the configured value.
 * @export
 * @interface AdminNamedEntityUpdateRequest
 */
export interface AdminNamedEntityUpdateRequest {
  /**
   *
   * @type {CoreResourceType}
   * @memberof AdminNamedEntityUpdateRequest
   */
  resourceType?: CoreResourceType;
  /**
   *
   * @type {AdminNamedEntityIdentifier}
   * @memberof AdminNamedEntityUpdateRequest
   */
  id?: AdminNamedEntityIdentifier;
  /**
   *
   * @type {AdminNamedEntityMetadata}
   * @memberof AdminNamedEntityUpdateRequest
   */
  metadata?: AdminNamedEntityMetadata;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminNamedEntityUpdateResponse
 */
export interface AdminNamedEntityUpdateResponse {}

/**
 * Container for node execution details and results.
 * @export
 * @interface AdminNodeExecutionClosure
 */
export interface AdminNodeExecutionClosure {
  /**
   * Links to a remotely stored, serialized core.LiteralMap of node execution outputs. DEPRECATED. Use GetNodeExecutionData to fetch output data instead.
   * @type {string}
   * @memberof AdminNodeExecutionClosure
   */
  outputUri?: string;
  /**
   *
   * @type {CoreExecutionError}
   * @memberof AdminNodeExecutionClosure
   */
  error?: CoreExecutionError;
  /**
   * Raw output data produced by this node execution. DEPRECATED. Use GetNodeExecutionData to fetch output data instead.
   * @type {CoreLiteralMap}
   * @memberof AdminNodeExecutionClosure
   */
  outputData?: CoreLiteralMap;
  /**
   * The last recorded phase for this node execution.
   * @type {CoreNodeExecutionPhase}
   * @memberof AdminNodeExecutionClosure
   */
  phase?: CoreNodeExecutionPhase;
  /**
   * Time at which the node execution began running.
   * @type {Date}
   * @memberof AdminNodeExecutionClosure
   */
  startedAt?: Date;
  /**
   * The amount of time the node execution spent running.
   * @type {string}
   * @memberof AdminNodeExecutionClosure
   */
  duration?: string;
  /**
   * Time at which the node execution was created.
   * @type {Date}
   * @memberof AdminNodeExecutionClosure
   */
  createdAt?: Date;
  /**
   * Time at which the node execution was last updated.
   * @type {Date}
   * @memberof AdminNodeExecutionClosure
   */
  updatedAt?: Date;
  /**
   *
   * @type {FlyteidladminWorkflowNodeMetadata}
   * @memberof AdminNodeExecutionClosure
   */
  workflowNodeMetadata?: FlyteidladminWorkflowNodeMetadata;
  /**
   *
   * @type {FlyteidladminTaskNodeMetadata}
   * @memberof AdminNodeExecutionClosure
   */
  taskNodeMetadata?: FlyteidladminTaskNodeMetadata;
  /**
   *
   * @type {string}
   * @memberof AdminNodeExecutionClosure
   */
  deckUri?: string;
  /**
   * dynamic_job_spec_uri is the location of the DynamicJobSpec proto message for a DynamicWorkflow. This is required to correctly recover partially completed executions where the subworkflow has already been compiled.
   * @type {string}
   * @memberof AdminNodeExecutionClosure
   */
  dynamicJobSpecUri?: string;
}

/**
 * Request to send a notification that a node execution event has occurred.
 * @export
 * @interface AdminNodeExecutionEventRequest
 */
export interface AdminNodeExecutionEventRequest {
  /**
   *
   * @type {string}
   * @memberof AdminNodeExecutionEventRequest
   */
  requestId?: string;
  /**
   * Details about the event that occurred.
   * @type {EventNodeExecutionEvent}
   * @memberof AdminNodeExecutionEventRequest
   */
  event?: EventNodeExecutionEvent;
}

/**
 *
 * @export
 * @interface AdminNodeExecutionEventResponse
 */
export interface AdminNodeExecutionEventResponse {}

/**
 * Response structure for NodeExecutionGetDataRequest which contains inputs and outputs for a node execution.
 * @export
 * @interface AdminNodeExecutionGetDataResponse
 */
export interface AdminNodeExecutionGetDataResponse {
  /**
   * Signed url to fetch a core.LiteralMap of node execution inputs. Deprecated: Please use full_inputs instead.
   * @type {AdminUrlBlob}
   * @memberof AdminNodeExecutionGetDataResponse
   */
  inputs?: AdminUrlBlob;
  /**
   * Signed url to fetch a core.LiteralMap of node execution outputs. Deprecated: Please use full_outputs instead.
   * @type {AdminUrlBlob}
   * @memberof AdminNodeExecutionGetDataResponse
   */
  outputs?: AdminUrlBlob;
  /**
   * Full_inputs will only be populated if they are under a configured size threshold.
   * @type {CoreLiteralMap}
   * @memberof AdminNodeExecutionGetDataResponse
   */
  fullInputs?: CoreLiteralMap;
  /**
   * Full_outputs will only be populated if they are under a configured size threshold.
   * @type {CoreLiteralMap}
   * @memberof AdminNodeExecutionGetDataResponse
   */
  fullOutputs?: CoreLiteralMap;
  /**
   * Optional Workflow closure for a dynamically generated workflow, in the case this node yields a dynamic workflow we return its structure here.
   * @type {FlyteidladminDynamicWorkflowNodeMetadata}
   * @memberof AdminNodeExecutionGetDataResponse
   */
  dynamicWorkflow?: FlyteidladminDynamicWorkflowNodeMetadata;
  /**
   *
   * @type {AdminFlyteURLs}
   * @memberof AdminNodeExecutionGetDataResponse
   */
  flyteUrls?: AdminFlyteURLs;
}

/**
 *
 * @export
 * @interface AdminNodeExecutionList
 */
export interface AdminNodeExecutionList {
  /**
   *
   * @type {Array<FlyteidladminNodeExecution>}
   * @memberof AdminNodeExecutionList
   */
  nodeExecutions?: Array<FlyteidladminNodeExecution>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminNodeExecutionList
   */
  token?: string;
}

/**
 *
 * @export
 * @interface AdminNodeExecutionMetaData
 */
export interface AdminNodeExecutionMetaData {
  /**
   * Node executions are grouped depending on retries of the parent Retry group is unique within the context of a parent node.
   * @type {string}
   * @memberof AdminNodeExecutionMetaData
   */
  retryGroup?: string;
  /**
   * Boolean flag indicating if the node has child nodes under it This can be true when a node contains a dynamic workflow which then produces child nodes.
   * @type {boolean}
   * @memberof AdminNodeExecutionMetaData
   */
  isParentNode?: boolean;
  /**
   *
   * @type {string}
   * @memberof AdminNodeExecutionMetaData
   */
  specNodeId?: string;
  /**
   * Boolean flag indicating if the node has contains a dynamic workflow which then produces child nodes. This is to distinguish between subworkflows and dynamic workflows which can both have is_parent_node as true.
   * @type {boolean}
   * @memberof AdminNodeExecutionMetaData
   */
  isDynamic?: boolean;
  /**
   * Boolean flag indicating if the node is an array node. This is intended to uniquely identify array nodes from other nodes which can have is_parent_node as true.
   * @type {boolean}
   * @memberof AdminNodeExecutionMetaData
   */
  isArray?: boolean;
}

/**
 * Represents a structure for notifications based on execution status. The notification content is configured within flyte admin but can be templatized. Future iterations could expose configuring notifications with custom content.
 * @export
 * @interface AdminNotification
 */
export interface AdminNotification {
  /**
   *
   * @type {Array<CoreWorkflowExecutionPhase>}
   * @memberof AdminNotification
   */
  phases?: Array<CoreWorkflowExecutionPhase>;
  /**
   *
   * @type {AdminEmailNotification}
   * @memberof AdminNotification
   */
  email?: AdminEmailNotification;
  /**
   *
   * @type {AdminPagerDutyNotification}
   * @memberof AdminNotification
   */
  pagerDuty?: AdminPagerDutyNotification;
  /**
   *
   * @type {AdminSlackNotification}
   * @memberof AdminNotification
   */
  slack?: AdminSlackNotification;
}

/**
 *
 * @export
 * @interface AdminNotificationList
 */
export interface AdminNotificationList {
  /**
   *
   * @type {Array<AdminNotification>}
   * @memberof AdminNotificationList
   */
  notifications?: Array<AdminNotification>;
}

/**
 * Defines a pager duty notification specification.
 * @export
 * @interface AdminPagerDutyNotification
 */
export interface AdminPagerDutyNotification {
  /**
   *
   * @type {Array<string>}
   * @memberof AdminPagerDutyNotification
   */
  recipientsEmail?: Array<string>;
}

/**
 * This MatchableAttribute configures selecting alternate plugin implementations for a given task type. In addition to an override implementation a selection of fallbacks can be provided or other modes for handling cases where the desired plugin override is not enabled in a given Flyte deployment.
 * @export
 * @interface AdminPluginOverride
 */
export interface AdminPluginOverride {
  /**
   * A predefined yet extensible Task type identifier.
   * @type {string}
   * @memberof AdminPluginOverride
   */
  taskType?: string;
  /**
   * A set of plugin ids which should handle tasks of this type instead of the default registered plugin. The list will be tried in order until a plugin is found with that id.
   * @type {Array<string>}
   * @memberof AdminPluginOverride
   */
  pluginId?: Array<string>;
  /**
   * Defines the behavior when no plugin from the plugin_id list is not found.
   * @type {PluginOverrideMissingPluginBehavior}
   * @memberof AdminPluginOverride
   */
  missingPluginBehavior?: PluginOverrideMissingPluginBehavior;
}

/**
 *
 * @export
 * @interface AdminPluginOverrides
 */
export interface AdminPluginOverrides {
  /**
   *
   * @type {Array<AdminPluginOverride>}
   * @memberof AdminPluginOverrides
   */
  overrides?: Array<AdminPluginOverride>;
}

/**
 * Top-level namespace used to classify different entities like workflows and executions.
 * @export
 * @interface AdminProject
 */
export interface AdminProject {
  /**
   * Globally unique project name.
   * @type {string}
   * @memberof AdminProject
   */
  id?: string;
  /**
   * Display name.
   * @type {string}
   * @memberof AdminProject
   */
  name?: string;
  /**
   *
   * @type {Array<AdminDomain>}
   * @memberof AdminProject
   */
  domains?: Array<AdminDomain>;
  /**
   *
   * @type {string}
   * @memberof AdminProject
   */
  description?: string;
  /**
   * Leverage Labels from flyteidl.admin.common.proto to tag projects with ownership information.
   * @type {AdminLabels}
   * @memberof AdminProject
   */
  labels?: AdminLabels;
  /**
   *
   * @type {ProjectProjectState}
   * @memberof AdminProject
   */
  state?: ProjectProjectState;
}

/**
 *
 * @export
 * @interface AdminProjectAttributes
 */
export interface AdminProjectAttributes {
  /**
   * Unique project id for which this set of attributes will be applied.
   * @type {string}
   * @memberof AdminProjectAttributes
   */
  project?: string;
  /**
   *
   * @type {AdminMatchingAttributes}
   * @memberof AdminProjectAttributes
   */
  matchingAttributes?: AdminMatchingAttributes;
}

/**
 *
 * @export
 * @interface AdminProjectAttributesDeleteRequest
 */
export interface AdminProjectAttributesDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof AdminProjectAttributesDeleteRequest
   */
  project?: string;
  /**
   *
   * @type {AdminMatchableResource}
   * @memberof AdminProjectAttributesDeleteRequest
   */
  resourceType?: AdminMatchableResource;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminProjectAttributesDeleteResponse
 */
export interface AdminProjectAttributesDeleteResponse {}

/**
 *
 * @export
 * @interface AdminProjectAttributesGetResponse
 */
export interface AdminProjectAttributesGetResponse {
  /**
   *
   * @type {AdminProjectAttributes}
   * @memberof AdminProjectAttributesGetResponse
   */
  attributes?: AdminProjectAttributes;
}

/**
 *
 * @export
 * @interface AdminProjectAttributesUpdateRequest
 */
export interface AdminProjectAttributesUpdateRequest {
  /**
   *
   * @type {AdminProjectAttributes}
   * @memberof AdminProjectAttributesUpdateRequest
   */
  attributes?: AdminProjectAttributes;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminProjectAttributesUpdateResponse
 */
export interface AdminProjectAttributesUpdateResponse {}

/**
 *
 * @export
 * @interface AdminProjectDomainAttributes
 */
export interface AdminProjectDomainAttributes {
  /**
   * Unique project id for which this set of attributes will be applied.
   * @type {string}
   * @memberof AdminProjectDomainAttributes
   */
  project?: string;
  /**
   * Unique domain id for which this set of attributes will be applied.
   * @type {string}
   * @memberof AdminProjectDomainAttributes
   */
  domain?: string;
  /**
   *
   * @type {AdminMatchingAttributes}
   * @memberof AdminProjectDomainAttributes
   */
  matchingAttributes?: AdminMatchingAttributes;
}

/**
 *
 * @export
 * @interface AdminProjectDomainAttributesDeleteRequest
 */
export interface AdminProjectDomainAttributesDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof AdminProjectDomainAttributesDeleteRequest
   */
  project?: string;
  /**
   *
   * @type {string}
   * @memberof AdminProjectDomainAttributesDeleteRequest
   */
  domain?: string;
  /**
   *
   * @type {AdminMatchableResource}
   * @memberof AdminProjectDomainAttributesDeleteRequest
   */
  resourceType?: AdminMatchableResource;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminProjectDomainAttributesDeleteResponse
 */
export interface AdminProjectDomainAttributesDeleteResponse {}

/**
 *
 * @export
 * @interface AdminProjectDomainAttributesGetResponse
 */
export interface AdminProjectDomainAttributesGetResponse {
  /**
   *
   * @type {AdminProjectDomainAttributes}
   * @memberof AdminProjectDomainAttributesGetResponse
   */
  attributes?: AdminProjectDomainAttributes;
}

/**
 *
 * @export
 * @interface AdminProjectDomainAttributesUpdateRequest
 */
export interface AdminProjectDomainAttributesUpdateRequest {
  /**
   *
   * @type {AdminProjectDomainAttributes}
   * @memberof AdminProjectDomainAttributesUpdateRequest
   */
  attributes?: AdminProjectDomainAttributes;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminProjectDomainAttributesUpdateResponse
 */
export interface AdminProjectDomainAttributesUpdateResponse {}

/**
 *
 * @export
 * @interface AdminProjectRegisterRequest
 */
export interface AdminProjectRegisterRequest {
  /**
   *
   * @type {AdminProject}
   * @memberof AdminProjectRegisterRequest
   */
  project?: AdminProject;
}

/**
 * Purposefully empty, may be updated in the future.
 * @export
 * @interface AdminProjectRegisterResponse
 */
export interface AdminProjectRegisterResponse {}

/**
 * Purposefully empty, may be updated in the future.
 * @export
 * @interface AdminProjectUpdateResponse
 */
export interface AdminProjectUpdateResponse {}

/**
 *
 * @export
 * @interface AdminProjects
 */
export interface AdminProjects {
  /**
   *
   * @type {Array<AdminProject>}
   * @memberof AdminProjects
   */
  projects?: Array<AdminProject>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminProjects
   */
  token?: string;
}

/**
 * Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.). See https://github.com/flyteorg/flyte/issues/211 for more background information.
 * @export
 * @interface AdminRawOutputDataConfig
 */
export interface AdminRawOutputDataConfig {
  /**
   *
   * @type {string}
   * @memberof AdminRawOutputDataConfig
   */
  outputLocationPrefix?: string;
}

/**
 * Reason is a single message annotated with a timestamp to indicate the instant the reason occurred.
 * @export
 * @interface AdminReason
 */
export interface AdminReason {
  /**
   * occurred_at is the timestamp indicating the instant that this reason happened.
   * @type {Date}
   * @memberof AdminReason
   */
  occurredAt?: Date;
  /**
   * message is the explanation for the most recent phase transition or status update.
   * @type {string}
   * @memberof AdminReason
   */
  message?: string;
}

/**
 * Defines complete set of information required to trigger an execution on a schedule.
 * @export
 * @interface AdminSchedule
 */
export interface AdminSchedule {
  /**
   *
   * @type {string}
   * @memberof AdminSchedule
   */
  cronExpression?: string;
  /**
   *
   * @type {AdminFixedRate}
   * @memberof AdminSchedule
   */
  rate?: AdminFixedRate;
  /**
   *
   * @type {AdminCronSchedule}
   * @memberof AdminSchedule
   */
  cronSchedule?: AdminCronSchedule;
  /**
   * Name of the input variable that the kickoff time will be supplied to when the workflow is kicked off.
   * @type {string}
   * @memberof AdminSchedule
   */
  kickoffTimeInputArg?: string;
}

/**
 * Defines a slack notification specification.
 * @export
 * @interface AdminSlackNotification
 */
export interface AdminSlackNotification {
  /**
   *
   * @type {Array<string>}
   * @memberof AdminSlackNotification
   */
  recipientsEmail?: Array<string>;
}

/**
 * Specifies sort ordering in a list request.
 * @export
 * @interface AdminSort
 */
export interface AdminSort {
  /**
   *
   * @type {string}
   * @memberof AdminSort
   */
  key?: string;
  /**
   *
   * @type {SortDirection}
   * @memberof AdminSort
   */
  direction?: SortDirection;
}

/**
 *
 * @export
 * @interface AdminSourceCode
 */
export interface AdminSourceCode {
  /**
   *
   * @type {string}
   * @memberof AdminSourceCode
   */
  link?: string;
}

/**
 * Represents system, rather than user-facing, metadata about an execution.
 * @export
 * @interface AdminSystemMetadata
 */
export interface AdminSystemMetadata {
  /**
   * Which execution cluster this execution ran on.
   * @type {string}
   * @memberof AdminSystemMetadata
   */
  executionCluster?: string;
  /**
   * Which kubernetes namespace the execution ran under.
   * @type {string}
   * @memberof AdminSystemMetadata
   */
  namespace?: string;
}

/**
 * Flyte workflows are composed of many ordered tasks. That is small, reusable, self-contained logical blocks arranged to process workflow inputs and produce a deterministic set of outputs. Tasks can come in many varieties tuned for specialized behavior.
 * @export
 * @interface AdminTask
 */
export interface AdminTask {
  /**
   * id represents the unique identifier of the task.
   * @type {CoreIdentifier}
   * @memberof AdminTask
   */
  id?: CoreIdentifier;
  /**
   * closure encapsulates all the fields that maps to a compiled version of the task.
   * @type {AdminTaskClosure}
   * @memberof AdminTask
   */
  closure?: AdminTaskClosure;
  /**
   * One-liner overview of the entity.
   * @type {string}
   * @memberof AdminTask
   */
  shortDescription?: string;
}

/**
 * Compute task attributes which include values derived from the TaskSpec, as well as plugin-specific data and task metadata.
 * @export
 * @interface AdminTaskClosure
 */
export interface AdminTaskClosure {
  /**
   * Represents the compiled representation of the task from the specification provided.
   * @type {CoreCompiledTask}
   * @memberof AdminTaskClosure
   */
  compiledTask?: CoreCompiledTask;
  /**
   * Time at which the task was created.
   * @type {Date}
   * @memberof AdminTaskClosure
   */
  createdAt?: Date;
}

/**
 * Container for task execution details and results.
 * @export
 * @interface AdminTaskExecutionClosure
 */
export interface AdminTaskExecutionClosure {
  /**
   * Path to remote data store where output blob is stored if the execution succeeded (and produced outputs). DEPRECATED. Use GetTaskExecutionData to fetch output data instead.
   * @type {string}
   * @memberof AdminTaskExecutionClosure
   */
  outputUri?: string;
  /**
   * Error information for the task execution. Populated if the execution failed.
   * @type {CoreExecutionError}
   * @memberof AdminTaskExecutionClosure
   */
  error?: CoreExecutionError;
  /**
   * Raw output data produced by this task execution. DEPRECATED. Use GetTaskExecutionData to fetch output data instead.
   * @type {CoreLiteralMap}
   * @memberof AdminTaskExecutionClosure
   */
  outputData?: CoreLiteralMap;
  /**
   * The last recorded phase for this task execution.
   * @type {CoreTaskExecutionPhase}
   * @memberof AdminTaskExecutionClosure
   */
  phase?: CoreTaskExecutionPhase;
  /**
   * Detailed log information output by the task execution.
   * @type {Array<CoreTaskLog>}
   * @memberof AdminTaskExecutionClosure
   */
  logs?: Array<CoreTaskLog>;
  /**
   * Time at which the task execution began running.
   * @type {Date}
   * @memberof AdminTaskExecutionClosure
   */
  startedAt?: Date;
  /**
   * The amount of time the task execution spent running.
   * @type {string}
   * @memberof AdminTaskExecutionClosure
   */
  duration?: string;
  /**
   * Time at which the task execution was created.
   * @type {Date}
   * @memberof AdminTaskExecutionClosure
   */
  createdAt?: Date;
  /**
   * Time at which the task execution was last updated.
   * @type {Date}
   * @memberof AdminTaskExecutionClosure
   */
  updatedAt?: Date;
  /**
   * Custom data specific to the task plugin.
   * @type {ProtobufStruct}
   * @memberof AdminTaskExecutionClosure
   */
  customInfo?: ProtobufStruct;
  /**
   * If there is an explanation for the most recent phase transition, the reason will capture it.
   * @type {string}
   * @memberof AdminTaskExecutionClosure
   */
  reason?: string;
  /**
   * A predefined yet extensible Task type identifier.
   * @type {string}
   * @memberof AdminTaskExecutionClosure
   */
  taskType?: string;
  /**
   * Metadata around how a task was executed.
   * @type {FlyteidleventTaskExecutionMetadata}
   * @memberof AdminTaskExecutionClosure
   */
  metadata?: FlyteidleventTaskExecutionMetadata;
  /**
   * The event version is used to indicate versioned changes in how data is maintained using this proto message. For example, event_verison > 0 means that maps tasks logs use the TaskExecutionMetadata ExternalResourceInfo fields for each subtask rather than the TaskLog in this message.
   * @type {number}
   * @memberof AdminTaskExecutionClosure
   */
  eventVersion?: number;
  /**
   * A time-series of the phase transition or update explanations. This, when compared to storing a singular reason as previously done, is much more valuable in visualizing and understanding historical evaluations.
   * @type {Array<AdminReason>}
   * @memberof AdminTaskExecutionClosure
   */
  reasons?: Array<AdminReason>;
}

/**
 * Request to send a notification that a task execution event has occurred.
 * @export
 * @interface AdminTaskExecutionEventRequest
 */
export interface AdminTaskExecutionEventRequest {
  /**
   *
   * @type {string}
   * @memberof AdminTaskExecutionEventRequest
   */
  requestId?: string;
  /**
   * Details about the event that occurred.
   * @type {EventTaskExecutionEvent}
   * @memberof AdminTaskExecutionEventRequest
   */
  event?: EventTaskExecutionEvent;
}

/**
 *
 * @export
 * @interface AdminTaskExecutionEventResponse
 */
export interface AdminTaskExecutionEventResponse {}

/**
 * Response structure for TaskExecutionGetDataRequest which contains inputs and outputs for a task execution.
 * @export
 * @interface AdminTaskExecutionGetDataResponse
 */
export interface AdminTaskExecutionGetDataResponse {
  /**
   * Signed url to fetch a core.LiteralMap of task execution inputs. Deprecated: Please use full_inputs instead.
   * @type {AdminUrlBlob}
   * @memberof AdminTaskExecutionGetDataResponse
   */
  inputs?: AdminUrlBlob;
  /**
   * Signed url to fetch a core.LiteralMap of task execution outputs. Deprecated: Please use full_outputs instead.
   * @type {AdminUrlBlob}
   * @memberof AdminTaskExecutionGetDataResponse
   */
  outputs?: AdminUrlBlob;
  /**
   * Full_inputs will only be populated if they are under a configured size threshold.
   * @type {CoreLiteralMap}
   * @memberof AdminTaskExecutionGetDataResponse
   */
  fullInputs?: CoreLiteralMap;
  /**
   * Full_outputs will only be populated if they are under a configured size threshold.
   * @type {CoreLiteralMap}
   * @memberof AdminTaskExecutionGetDataResponse
   */
  fullOutputs?: CoreLiteralMap;
  /**
   *
   * @type {AdminFlyteURLs}
   * @memberof AdminTaskExecutionGetDataResponse
   */
  flyteUrls?: AdminFlyteURLs;
}

/**
 *
 * @export
 * @interface AdminTaskExecutionList
 */
export interface AdminTaskExecutionList {
  /**
   *
   * @type {Array<FlyteidladminTaskExecution>}
   * @memberof AdminTaskExecutionList
   */
  taskExecutions?: Array<FlyteidladminTaskExecution>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminTaskExecutionList
   */
  token?: string;
}

/**
 *
 * @export
 * @interface AdminTaskList
 */
export interface AdminTaskList {
  /**
   * A list of tasks returned based on the request.
   * @type {Array<AdminTask>}
   * @memberof AdminTaskList
   */
  tasks?: Array<AdminTask>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminTaskList
   */
  token?: string;
}

/**
 * Defines task resource defaults and limits that will be applied at task registration.
 * @export
 * @interface AdminTaskResourceAttributes
 */
export interface AdminTaskResourceAttributes {
  /**
   *
   * @type {AdminTaskResourceSpec}
   * @memberof AdminTaskResourceAttributes
   */
  defaults?: AdminTaskResourceSpec;
  /**
   *
   * @type {AdminTaskResourceSpec}
   * @memberof AdminTaskResourceAttributes
   */
  limits?: AdminTaskResourceSpec;
}

/**
 * Defines a set of overridable task resource attributes set during task registration.
 * @export
 * @interface AdminTaskResourceSpec
 */
export interface AdminTaskResourceSpec {
  /**
   *
   * @type {string}
   * @memberof AdminTaskResourceSpec
   */
  cpu?: string;
  /**
   *
   * @type {string}
   * @memberof AdminTaskResourceSpec
   */
  gpu?: string;
  /**
   *
   * @type {string}
   * @memberof AdminTaskResourceSpec
   */
  memory?: string;
  /**
   *
   * @type {string}
   * @memberof AdminTaskResourceSpec
   */
  storage?: string;
  /**
   *
   * @type {string}
   * @memberof AdminTaskResourceSpec
   */
  ephemeralStorage?: string;
}

/**
 * Represents a structure that encapsulates the user-configured specification of the task.
 * @export
 * @interface AdminTaskSpec
 */
export interface AdminTaskSpec {
  /**
   * Template of the task that encapsulates all the metadata of the task.
   * @type {CoreTaskTemplate}
   * @memberof AdminTaskSpec
   */
  template?: CoreTaskTemplate;
  /**
   * Represents the specification for description entity.
   * @type {AdminDescriptionEntity}
   * @memberof AdminTaskSpec
   */
  description?: AdminDescriptionEntity;
}

/**
 * Represents a string url and associated metadata used throughout the platform.
 * @export
 * @interface AdminUrlBlob
 */
export interface AdminUrlBlob {
  /**
   * Actual url value.
   * @type {string}
   * @memberof AdminUrlBlob
   */
  url?: string;
  /**
   * Represents the size of the file accessible at the above url.
   * @type {string}
   * @memberof AdminUrlBlob
   */
  bytes?: string;
}

/**
 *
 * @export
 * @interface AdminVersion
 */
export interface AdminVersion {
  /**
   *
   * @type {string}
   * @memberof AdminVersion
   */
  build?: string;
  /**
   *
   * @type {string}
   * @memberof AdminVersion
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof AdminVersion
   */
  buildTime?: string;
}

/**
 * Represents the workflow structure stored in the Admin A workflow is created by ordering tasks and associating outputs to inputs in order to produce a directed-acyclic execution graph.
 * @export
 * @interface AdminWorkflow
 */
export interface AdminWorkflow {
  /**
   * id represents the unique identifier of the workflow.
   * @type {CoreIdentifier}
   * @memberof AdminWorkflow
   */
  id?: CoreIdentifier;
  /**
   * closure encapsulates all the fields that maps to a compiled version of the workflow.
   * @type {AdminWorkflowClosure}
   * @memberof AdminWorkflow
   */
  closure?: AdminWorkflowClosure;
  /**
   * One-liner overview of the entity.
   * @type {string}
   * @memberof AdminWorkflow
   */
  shortDescription?: string;
}

/**
 *
 * @export
 * @interface AdminWorkflowAttributes
 */
export interface AdminWorkflowAttributes {
  /**
   * Unique project id for which this set of attributes will be applied.
   * @type {string}
   * @memberof AdminWorkflowAttributes
   */
  project?: string;
  /**
   * Unique domain id for which this set of attributes will be applied.
   * @type {string}
   * @memberof AdminWorkflowAttributes
   */
  domain?: string;
  /**
   * Workflow name for which this set of attributes will be applied.
   * @type {string}
   * @memberof AdminWorkflowAttributes
   */
  workflow?: string;
  /**
   *
   * @type {AdminMatchingAttributes}
   * @memberof AdminWorkflowAttributes
   */
  matchingAttributes?: AdminMatchingAttributes;
}

/**
 *
 * @export
 * @interface AdminWorkflowAttributesDeleteRequest
 */
export interface AdminWorkflowAttributesDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof AdminWorkflowAttributesDeleteRequest
   */
  project?: string;
  /**
   *
   * @type {string}
   * @memberof AdminWorkflowAttributesDeleteRequest
   */
  domain?: string;
  /**
   *
   * @type {string}
   * @memberof AdminWorkflowAttributesDeleteRequest
   */
  workflow?: string;
  /**
   *
   * @type {AdminMatchableResource}
   * @memberof AdminWorkflowAttributesDeleteRequest
   */
  resourceType?: AdminMatchableResource;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminWorkflowAttributesDeleteResponse
 */
export interface AdminWorkflowAttributesDeleteResponse {}

/**
 * Response to get an individual workflow attribute override.
 * @export
 * @interface AdminWorkflowAttributesGetResponse
 */
export interface AdminWorkflowAttributesGetResponse {
  /**
   *
   * @type {AdminWorkflowAttributes}
   * @memberof AdminWorkflowAttributesGetResponse
   */
  attributes?: AdminWorkflowAttributes;
}

/**
 *
 * @export
 * @interface AdminWorkflowAttributesUpdateRequest
 */
export interface AdminWorkflowAttributesUpdateRequest {
  /**
   *
   * @type {AdminWorkflowAttributes}
   * @memberof AdminWorkflowAttributesUpdateRequest
   */
  attributes?: AdminWorkflowAttributes;
}

/**
 * Purposefully empty, may be populated in the future.
 * @export
 * @interface AdminWorkflowAttributesUpdateResponse
 */
export interface AdminWorkflowAttributesUpdateResponse {}

/**
 * A container holding the compiled workflow produced from the WorkflowSpec and additional metadata.
 * @export
 * @interface AdminWorkflowClosure
 */
export interface AdminWorkflowClosure {
  /**
   * Represents the compiled representation of the workflow from the specification provided.
   * @type {CoreCompiledWorkflowClosure}
   * @memberof AdminWorkflowClosure
   */
  compiledWorkflow?: CoreCompiledWorkflowClosure;
  /**
   * Time at which the workflow was created.
   * @type {Date}
   * @memberof AdminWorkflowClosure
   */
  createdAt?: Date;
}

/**
 *
 * @export
 * @interface AdminWorkflowCreateRequest
 */
export interface AdminWorkflowCreateRequest {
  /**
   *
   * @type {CoreIdentifier}
   * @memberof AdminWorkflowCreateRequest
   */
  id?: CoreIdentifier;
  /**
   *
   * @type {AdminWorkflowSpec}
   * @memberof AdminWorkflowCreateRequest
   */
  spec?: AdminWorkflowSpec;
}

/**
 *
 * @export
 * @interface AdminWorkflowCreateResponse
 */
export interface AdminWorkflowCreateResponse {}

/**
 * Adds defaults for customizable workflow-execution specifications and overrides.
 * @export
 * @interface AdminWorkflowExecutionConfig
 */
export interface AdminWorkflowExecutionConfig {
  /**
   * Can be used to control the number of parallel nodes to run within the workflow. This is useful to achieve fairness.
   * @type {number}
   * @memberof AdminWorkflowExecutionConfig
   */
  maxParallelism?: number;
  /**
   * Indicates security context permissions for executions triggered with this matchable attribute.
   * @type {CoreSecurityContext}
   * @memberof AdminWorkflowExecutionConfig
   */
  securityContext?: CoreSecurityContext;
  /**
   * Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.).
   * @type {AdminRawOutputDataConfig}
   * @memberof AdminWorkflowExecutionConfig
   */
  rawOutputDataConfig?: AdminRawOutputDataConfig;
  /**
   * Custom labels to be applied to a triggered execution resource.
   * @type {AdminLabels}
   * @memberof AdminWorkflowExecutionConfig
   */
  labels?: AdminLabels;
  /**
   * Custom annotations to be applied to a triggered execution resource.
   * @type {AdminAnnotations}
   * @memberof AdminWorkflowExecutionConfig
   */
  annotations?: AdminAnnotations;
  /**
   * Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.
   * @type {boolean}
   * @memberof AdminWorkflowExecutionConfig
   */
  interruptible?: boolean;
  /**
   * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
   * @type {boolean}
   * @memberof AdminWorkflowExecutionConfig
   */
  overwriteCache?: boolean;
  /**
   * Environment variables to be set for the execution.
   * @type {AdminEnvs}
   * @memberof AdminWorkflowExecutionConfig
   */
  envs?: AdminEnvs;
}

/**
 * Request to send a notification that a workflow execution event has occurred.
 * @export
 * @interface AdminWorkflowExecutionEventRequest
 */
export interface AdminWorkflowExecutionEventRequest {
  /**
   *
   * @type {string}
   * @memberof AdminWorkflowExecutionEventRequest
   */
  requestId?: string;
  /**
   * Details about the event that occurred.
   * @type {EventWorkflowExecutionEvent}
   * @memberof AdminWorkflowExecutionEventRequest
   */
  event?: EventWorkflowExecutionEvent;
}

/**
 *
 * @export
 * @interface AdminWorkflowExecutionEventResponse
 */
export interface AdminWorkflowExecutionEventResponse {}

/**
 * Response structure for WorkflowExecutionGetDataRequest which contains inputs and outputs for an execution.
 * @export
 * @interface AdminWorkflowExecutionGetDataResponse
 */
export interface AdminWorkflowExecutionGetDataResponse {
  /**
   * Signed url to fetch a core.LiteralMap of execution outputs. Deprecated: Please use full_outputs instead.
   * @type {AdminUrlBlob}
   * @memberof AdminWorkflowExecutionGetDataResponse
   */
  outputs?: AdminUrlBlob;
  /**
   * Signed url to fetch a core.LiteralMap of execution inputs. Deprecated: Please use full_inputs instead.
   * @type {AdminUrlBlob}
   * @memberof AdminWorkflowExecutionGetDataResponse
   */
  inputs?: AdminUrlBlob;
  /**
   * Full_inputs will only be populated if they are under a configured size threshold.
   * @type {CoreLiteralMap}
   * @memberof AdminWorkflowExecutionGetDataResponse
   */
  fullInputs?: CoreLiteralMap;
  /**
   * Full_outputs will only be populated if they are under a configured size threshold.
   * @type {CoreLiteralMap}
   * @memberof AdminWorkflowExecutionGetDataResponse
   */
  fullOutputs?: CoreLiteralMap;
}

/**
 * WorkflowExecutionGetMetricsResponse represents the response containing metrics for the specified workflow execution.
 * @export
 * @interface AdminWorkflowExecutionGetMetricsResponse
 */
export interface AdminWorkflowExecutionGetMetricsResponse {
  /**
   * Span defines the top-level breakdown of the workflows execution. More precise information is nested in a hierarchical structure using Flyte entity references.
   * @type {CoreSpan}
   * @memberof AdminWorkflowExecutionGetMetricsResponse
   */
  span?: CoreSpan;
}

/**
 *
 * @export
 * @interface AdminWorkflowList
 */
export interface AdminWorkflowList {
  /**
   * A list of workflows returned based on the request.
   * @type {Array<AdminWorkflow>}
   * @memberof AdminWorkflowList
   */
  workflows?: Array<AdminWorkflow>;
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
   * @type {string}
   * @memberof AdminWorkflowList
   */
  token?: string;
}

/**
 * Represents a structure that encapsulates the specification of the workflow.
 * @export
 * @interface AdminWorkflowSpec
 */
export interface AdminWorkflowSpec {
  /**
   * Template of the task that encapsulates all the metadata of the workflow.
   * @type {CoreWorkflowTemplate}
   * @memberof AdminWorkflowSpec
   */
  template?: CoreWorkflowTemplate;
  /**
   * Workflows that are embedded into other workflows need to be passed alongside the parent workflow to the propeller compiler (since the compiler doesn't have any knowledge of other workflows - ie, it doesn't reach out to Admin to see other registered workflows).  In fact, subworkflows do not even need to be registered.
   * @type {Array<CoreWorkflowTemplate>}
   * @memberof AdminWorkflowSpec
   */
  subWorkflows?: Array<CoreWorkflowTemplate>;
  /**
   * Represents the specification for description entity.
   * @type {AdminDescriptionEntity}
   * @memberof AdminWorkflowSpec
   */
  description?: AdminDescriptionEntity;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum BlobTypeBlobDimensionality {
  SINGLE = <any>"SINGLE",
  MULTIPART = <any>"MULTIPART",
}

/**
 * Indicates the status of a catalog reservation operation.   - RESERVATION_DISABLED: Used to indicate that reservations are disabled  - RESERVATION_ACQUIRED: Used to indicate that a reservation was successfully acquired or extended  - RESERVATION_EXISTS: Used to indicate that an active reservation currently exists  - RESERVATION_RELEASED: Used to indicate that the reservation has been successfully released  - RESERVATION_FAILURE: Used to indicate that a reservation operation resulted in failure
 * @export
 * @enum {string}
 */
export enum CatalogReservationStatus {
  DISABLED = <any>"RESERVATION_DISABLED",
  ACQUIRED = <any>"RESERVATION_ACQUIRED",
  EXISTS = <any>"RESERVATION_EXISTS",
  RELEASED = <any>"RESERVATION_RELEASED",
  FAILURE = <any>"RESERVATION_FAILURE",
}

/**
 * - GT: Greater Than  - LT: Less Than
 * @export
 * @enum {string}
 */
export enum ComparisonExpressionOperator {
  EQ = <any>"EQ",
  NEQ = <any>"NEQ",
  GT = <any>"GT",
  GTE = <any>"GTE",
  LT = <any>"LT",
  LTE = <any>"LTE",
}

/**
 * - AND: Conjunction
 * @export
 * @enum {string}
 */
export enum ConjunctionExpressionLogicalOperator {
  AND = <any>"AND",
  OR = <any>"OR",
}

/**
 *
 * @export
 * @interface ConnectionSetIdList
 */
export interface ConnectionSetIdList {
  /**
   *
   * @type {Array<string>}
   * @memberof ConnectionSetIdList
   */
  ids?: Array<string>;
}

/**
 * Architecture-type the container image supports.
 * @export
 * @enum {string}
 */
export enum ContainerArchitecture {
  UNKNOWN = <any>"UNKNOWN",
  AMD64 = <any>"AMD64",
  ARM64 = <any>"ARM64",
  ARMV6 = <any>"ARM_V6",
  ARMV7 = <any>"ARM_V7",
}

/**
 * Links a variable to an alias.
 * @export
 * @interface CoreAlias
 */
export interface CoreAlias {
  /**
   * Must match one of the output variable names on a node.
   * @type {string}
   * @memberof CoreAlias
   */
  _var?: string;
  /**
   * A workflow-level unique alias that downstream nodes can refer to in their input.
   * @type {string}
   * @memberof CoreAlias
   */
  alias?: string;
}

/**
 * ApproveCondition represents a dependency on an external approval. During execution, this will manifest as a boolean signal with the provided signal_id.
 * @export
 * @interface CoreApproveCondition
 */
export interface CoreApproveCondition {
  /**
   * A unique identifier for the requested boolean signal.
   * @type {string}
   * @memberof CoreApproveCondition
   */
  signalId?: string;
}

/**
 * ArrayNode is a Flyte node type that simplifies the execution of a sub-node over a list of input values. An ArrayNode can be executed with configurable parallelism (separate from the parent workflow) and can be configured to succeed when a certain number of sub-nodes succeed.
 * @export
 * @interface CoreArrayNode
 */
export interface CoreArrayNode {
  /**
   * node is the sub-node that will be executed for each element in the array.
   * @type {CoreNode}
   * @memberof CoreArrayNode
   */
  node?: CoreNode;
  /**
   * parallelism defines the minimum number of instances to bring up concurrently at any given point. Note that this is an optimistic restriction and that, due to network partitioning or other failures, the actual number of currently running instances might be more. This has to be a positive number if assigned. Default value is size.
   * @type {number}
   * @memberof CoreArrayNode
   */
  parallelism?: number;
  /**
   * min_successes is an absolute number of the minimum number of successful completions of sub-nodes. As soon as this criteria is met, the ArrayNode will be marked as successful and outputs will be computed. This has to be a non-negative number if assigned. Default value is size (if specified).
   * @type {number}
   * @memberof CoreArrayNode
   */
  minSuccesses?: number;
  /**
   * If the array job size is not known beforehand, the min_success_ratio can instead be used to determine when an ArrayNode can be marked successful.
   * @type {number}
   * @memberof CoreArrayNode
   */
  minSuccessRatio?: number;
}

/**
 * A simple byte array with a tag to help different parts of the system communicate about what is in the byte array. It's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data.
 * @export
 * @interface CoreBinary
 */
export interface CoreBinary {
  /**
   *
   * @type {string}
   * @memberof CoreBinary
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof CoreBinary
   */
  tag?: string;
}

/**
 * An input/output binding of a variable to either static value or a node output.
 * @export
 * @interface CoreBinding
 */
export interface CoreBinding {
  /**
   * Variable name must match an input/output variable of the node.
   * @type {string}
   * @memberof CoreBinding
   */
  _var?: string;
  /**
   * Data to use to bind this variable.
   * @type {CoreBindingData}
   * @memberof CoreBinding
   */
  binding?: CoreBindingData;
}

/**
 * Specifies either a simple value or a reference to another output.
 * @export
 * @interface CoreBindingData
 */
export interface CoreBindingData {
  /**
   * A simple scalar value.
   * @type {CoreScalar}
   * @memberof CoreBindingData
   */
  scalar?: CoreScalar;
  /**
   * A collection of binding data. This allows nesting of binding data to any number of levels.
   * @type {CoreBindingDataCollection}
   * @memberof CoreBindingData
   */
  collection?: CoreBindingDataCollection;
  /**
   * References an output promised by another node.
   * @type {CoreOutputReference}
   * @memberof CoreBindingData
   */
  promise?: CoreOutputReference;
  /**
   * A map of bindings. The key is always a string.
   * @type {CoreBindingDataMap}
   * @memberof CoreBindingData
   */
  map?: CoreBindingDataMap;
  /**
   *
   * @type {CoreUnionInfo}
   * @memberof CoreBindingData
   */
  union?: CoreUnionInfo;
}

/**
 * A collection of BindingData items.
 * @export
 * @interface CoreBindingDataCollection
 */
export interface CoreBindingDataCollection {
  /**
   *
   * @type {Array<CoreBindingData>}
   * @memberof CoreBindingDataCollection
   */
  bindings?: Array<CoreBindingData>;
}

/**
 * A map of BindingData items.
 * @export
 * @interface CoreBindingDataMap
 */
export interface CoreBindingDataMap {
  /**
   *
   * @type {{ [key: string]: CoreBindingData; }}
   * @memberof CoreBindingDataMap
   */
  bindings?: { [key: string]: CoreBindingData };
}

/**
 * Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is. There are no restrictions on how the uri is formatted since it will depend on how to interact with the store.
 * @export
 * @interface CoreBlob
 */
export interface CoreBlob {
  /**
   *
   * @type {CoreBlobMetadata}
   * @memberof CoreBlob
   */
  metadata?: CoreBlobMetadata;
  /**
   *
   * @type {string}
   * @memberof CoreBlob
   */
  uri?: string;
}

/**
 *
 * @export
 * @interface CoreBlobMetadata
 */
export interface CoreBlobMetadata {
  /**
   *
   * @type {CoreBlobType}
   * @memberof CoreBlobMetadata
   */
  type?: CoreBlobType;
}

/**
 *
 * @export
 * @interface CoreBlobType
 */
export interface CoreBlobType {
  /**
   *
   * @type {string}
   * @memberof CoreBlobType
   */
  format?: string;
  /**
   *
   * @type {BlobTypeBlobDimensionality}
   * @memberof CoreBlobType
   */
  dimensionality?: BlobTypeBlobDimensionality;
}

/**
 * Defines a boolean expression tree. It can be a simple or a conjunction expression. Multiple expressions can be combined using a conjunction or a disjunction to result in a final boolean result.
 * @export
 * @interface CoreBooleanExpression
 */
export interface CoreBooleanExpression {
  /**
   *
   * @type {CoreConjunctionExpression}
   * @memberof CoreBooleanExpression
   */
  conjunction?: CoreConjunctionExpression;
  /**
   *
   * @type {CoreComparisonExpression}
   * @memberof CoreBooleanExpression
   */
  comparison?: CoreComparisonExpression;
}

/**
 * BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at runtime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primitives).
 * @export
 * @interface CoreBranchNode
 */
export interface CoreBranchNode {
  /**
   *
   * @type {CoreIfElseBlock}
   * @memberof CoreBranchNode
   */
  ifElse?: CoreIfElseBlock;
}

/**
 *
 * @export
 * @interface CoreCatalogArtifactTag
 */
export interface CoreCatalogArtifactTag {
  /**
   *
   * @type {string}
   * @memberof CoreCatalogArtifactTag
   */
  artifactId?: string;
  /**
   *
   * @type {string}
   * @memberof CoreCatalogArtifactTag
   */
  name?: string;
}

/**
 * - CACHE_DISABLED: Used to indicate that caching was disabled  - CACHE_MISS: Used to indicate that the cache lookup resulted in no matches  - CACHE_HIT: used to indicate that the associated artifact was a result of a previous execution  - CACHE_POPULATED: used to indicate that the resultant artifact was added to the cache  - CACHE_LOOKUP_FAILURE: Used to indicate that cache lookup failed because of an error  - CACHE_PUT_FAILURE: Used to indicate that cache lookup failed because of an error  - CACHE_SKIPPED: Used to indicate the cache lookup was skipped
 * @export
 * @enum {string}
 */
export enum CoreCatalogCacheStatus {
  DISABLED = <any>"CACHE_DISABLED",
  MISS = <any>"CACHE_MISS",
  HIT = <any>"CACHE_HIT",
  POPULATED = <any>"CACHE_POPULATED",
  LOOKUPFAILURE = <any>"CACHE_LOOKUP_FAILURE",
  PUTFAILURE = <any>"CACHE_PUT_FAILURE",
  SKIPPED = <any>"CACHE_SKIPPED",
}

/**
 *
 * @export
 * @interface CoreCatalogMetadata
 */
export interface CoreCatalogMetadata {
  /**
   *
   * @type {CoreIdentifier}
   * @memberof CoreCatalogMetadata
   */
  datasetId?: CoreIdentifier;
  /**
   *
   * @type {CoreCatalogArtifactTag}
   * @memberof CoreCatalogMetadata
   */
  artifactTag?: CoreCatalogArtifactTag;
  /**
   *
   * @type {CoreTaskExecutionIdentifier}
   * @memberof CoreCatalogMetadata
   */
  sourceTaskExecution?: CoreTaskExecutionIdentifier;
}

/**
 * Defines a 2-level tree where the root is a comparison operator and Operands are primitives or known variables. Each expression results in a boolean result.
 * @export
 * @interface CoreComparisonExpression
 */
export interface CoreComparisonExpression {
  /**
   *
   * @type {ComparisonExpressionOperator}
   * @memberof CoreComparisonExpression
   */
  operator?: ComparisonExpressionOperator;
  /**
   *
   * @type {CoreOperand}
   * @memberof CoreComparisonExpression
   */
  leftValue?: CoreOperand;
  /**
   *
   * @type {CoreOperand}
   * @memberof CoreComparisonExpression
   */
  rightValue?: CoreOperand;
}

/**
 *
 * @export
 * @interface CoreCompiledTask
 */
export interface CoreCompiledTask {
  /**
   *
   * @type {CoreTaskTemplate}
   * @memberof CoreCompiledTask
   */
  template?: CoreTaskTemplate;
}

/**
 *
 * @export
 * @interface CoreCompiledWorkflow
 */
export interface CoreCompiledWorkflow {
  /**
   *
   * @type {CoreWorkflowTemplate}
   * @memberof CoreCompiledWorkflow
   */
  template?: CoreWorkflowTemplate;
  /**
   * For internal use only! This field is used by the system and must not be filled in. Any values set will be ignored.
   * @type {CoreConnectionSet}
   * @memberof CoreCompiledWorkflow
   */
  connections?: CoreConnectionSet;
}

/**
 * A Compiled Workflow Closure contains all the information required to start a new execution, or to visualize a workflow and its details. The CompiledWorkflowClosure should always contain a primary workflow, that is the main workflow that will being the execution. All subworkflows are denormalized. WorkflowNodes refer to the workflow identifiers of compiled subworkflows.
 * @export
 * @interface CoreCompiledWorkflowClosure
 */
export interface CoreCompiledWorkflowClosure {
  /**
   *
   * @type {CoreCompiledWorkflow}
   * @memberof CoreCompiledWorkflowClosure
   */
  primary?: CoreCompiledWorkflow;
  /**
   *
   * @type {Array<CoreCompiledWorkflow>}
   * @memberof CoreCompiledWorkflowClosure
   */
  subWorkflows?: Array<CoreCompiledWorkflow>;
  /**
   *
   * @type {Array<CoreCompiledTask>}
   * @memberof CoreCompiledWorkflowClosure
   */
  tasks?: Array<CoreCompiledTask>;
}

/**
 * Defines a conjunction expression of two boolean expressions.
 * @export
 * @interface CoreConjunctionExpression
 */
export interface CoreConjunctionExpression {
  /**
   *
   * @type {ConjunctionExpressionLogicalOperator}
   * @memberof CoreConjunctionExpression
   */
  operator?: ConjunctionExpressionLogicalOperator;
  /**
   *
   * @type {CoreBooleanExpression}
   * @memberof CoreConjunctionExpression
   */
  leftExpression?: CoreBooleanExpression;
  /**
   *
   * @type {CoreBooleanExpression}
   * @memberof CoreConjunctionExpression
   */
  rightExpression?: CoreBooleanExpression;
}

/**
 *
 * @export
 * @interface CoreConnectionSet
 */
export interface CoreConnectionSet {
  /**
   *
   * @type {{ [key: string]: ConnectionSetIdList; }}
   * @memberof CoreConnectionSet
   */
  downstream?: { [key: string]: ConnectionSetIdList };
  /**
   *
   * @type {{ [key: string]: ConnectionSetIdList; }}
   * @memberof CoreConnectionSet
   */
  upstream?: { [key: string]: ConnectionSetIdList };
}

/**
 *
 * @export
 * @interface CoreContainer
 */
export interface CoreContainer {
  /**
   *
   * @type {string}
   * @memberof CoreContainer
   */
  image?: string;
  /**
   * Command to be executed, if not provided, the default entrypoint in the container image will be used.
   * @type {Array<string>}
   * @memberof CoreContainer
   */
  command?: Array<string>;
  /**
   * These will default to Flyte given paths. If provided, the system will not append known paths. If the task still needs flyte's inputs and outputs path, add $(FLYTE_INPUT_FILE), $(FLYTE_OUTPUT_FILE) wherever makes sense and the system will populate these before executing the container.
   * @type {Array<string>}
   * @memberof CoreContainer
   */
  args?: Array<string>;
  /**
   * Container resources requirement as specified by the container engine.
   * @type {CoreResources}
   * @memberof CoreContainer
   */
  resources?: CoreResources;
  /**
   * Environment variables will be set as the container is starting up.
   * @type {Array<CoreKeyValuePair>}
   * @memberof CoreContainer
   */
  env?: Array<CoreKeyValuePair>;
  /**
   * Allows extra configs to be available for the container. TODO: elaborate on how configs will become available. Deprecated, please use TaskTemplate.config instead.
   * @type {Array<CoreKeyValuePair>}
   * @memberof CoreContainer
   */
  config?: Array<CoreKeyValuePair>;
  /**
   *
   * @type {Array<CoreContainerPort>}
   * @memberof CoreContainer
   */
  ports?: Array<CoreContainerPort>;
  /**
   *
   * @type {CoreDataLoadingConfig}
   * @memberof CoreContainer
   */
  dataConfig?: CoreDataLoadingConfig;
  /**
   *
   * @type {ContainerArchitecture}
   * @memberof CoreContainer
   */
  architecture?: ContainerArchitecture;
}

/**
 * Defines port properties for a container.
 * @export
 * @interface CoreContainerPort
 */
export interface CoreContainerPort {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   * @type {number}
   * @memberof CoreContainerPort
   */
  containerPort?: number;
}

/**
 * This configuration allows executing raw containers in Flyte using the Flyte CoPilot system. Flyte CoPilot, eliminates the needs of flytekit or sdk inside the container. Any inputs required by the users container are side-loaded in the input_path Any outputs generated by the user container - within output_path are automatically uploaded.
 * @export
 * @interface CoreDataLoadingConfig
 */
export interface CoreDataLoadingConfig {
  /**
   *
   * @type {boolean}
   * @memberof CoreDataLoadingConfig
   */
  enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof CoreDataLoadingConfig
   */
  inputPath?: string;
  /**
   *
   * @type {string}
   * @memberof CoreDataLoadingConfig
   */
  outputPath?: string;
  /**
   *
   * @type {DataLoadingConfigLiteralMapFormat}
   * @memberof CoreDataLoadingConfig
   */
  format?: DataLoadingConfigLiteralMapFormat;
  /**
   *
   * @type {CoreIOStrategy}
   * @memberof CoreDataLoadingConfig
   */
  ioStrategy?: CoreIOStrategy;
}

/**
 * Enables declaring enum types, with predefined string values For len(values) > 0, the first value in the ordered list is regarded as the default value. If you wish To provide no defaults, make the first value as undefined.
 * @export
 * @interface CoreEnumType
 */
export interface CoreEnumType {
  /**
   * Predefined set of enum values.
   * @type {Array<string>}
   * @memberof CoreEnumType
   */
  values?: Array<string>;
}

/**
 * Represents an error thrown from a node.
 * @export
 * @interface CoreError
 */
export interface CoreError {
  /**
   * The node id that threw the error.
   * @type {string}
   * @memberof CoreError
   */
  failedNodeId?: string;
  /**
   * Error message thrown.
   * @type {string}
   * @memberof CoreError
   */
  message?: string;
}

/**
 * Represents the error message from the execution.
 * @export
 * @interface CoreExecutionError
 */
export interface CoreExecutionError {
  /**
   *
   * @type {string}
   * @memberof CoreExecutionError
   */
  code?: string;
  /**
   * Detailed description of the error - including stack trace.
   * @type {string}
   * @memberof CoreExecutionError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof CoreExecutionError
   */
  errorUri?: string;
  /**
   *
   * @type {ExecutionErrorErrorKind}
   * @memberof CoreExecutionError
   */
  kind?: ExecutionErrorErrorKind;
}

/**
 * Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to allocate to a task.
 * @export
 * @interface CoreExtendedResources
 */
export interface CoreExtendedResources {
  /**
   * GPU accelerator to select for task. Contains information about device type, and for multi-instance GPUs, the partition size to use.
   * @type {CoreGPUAccelerator}
   * @memberof CoreExtendedResources
   */
  gpuAccelerator?: CoreGPUAccelerator;
}

/**
 * Metadata associated with the GPU accelerator to allocate to a task. Contains information about device type, and for multi-instance GPUs, the partition size to use.
 * @export
 * @interface CoreGPUAccelerator
 */
export interface CoreGPUAccelerator {
  /**
   * This can be any arbitrary string, and should be informed by the labels or taints associated with the nodes in question. Default cloud provider labels typically use the following values: `nvidia-tesla-t4`, `nvidia-tesla-a100`, etc.
   * @type {string}
   * @memberof CoreGPUAccelerator
   */
  device?: string;
  /**
   *
   * @type {boolean}
   * @memberof CoreGPUAccelerator
   */
  unpartitioned?: boolean;
  /**
   * Like `device`, this can be any arbitrary string, and should be informed by the labels or taints associated with the nodes in question. Default cloud provider labels typically use the following values: `1g.5gb`, `2g.10gb`, etc.
   * @type {string}
   * @memberof CoreGPUAccelerator
   */
  partitionSize?: string;
}

/**
 * GateNode refers to the condition that is required for the gate to successfully complete.
 * @export
 * @interface CoreGateNode
 */
export interface CoreGateNode {
  /**
   * ApproveCondition represents a dependency on an external approval provided by a boolean signal.
   * @type {CoreApproveCondition}
   * @memberof CoreGateNode
   */
  approve?: CoreApproveCondition;
  /**
   * SignalCondition represents a dependency on an signal.
   * @type {CoreSignalCondition}
   * @memberof CoreGateNode
   */
  signal?: CoreSignalCondition;
  /**
   * SleepCondition represents a dependency on waiting for the specified duration.
   * @type {CoreSleepCondition}
   * @memberof CoreGateNode
   */
  sleep?: CoreSleepCondition;
}

/**
 *
 * @export
 * @interface CoreIOStrategy
 */
export interface CoreIOStrategy {
  /**
   *
   * @type {IOStrategyDownloadMode}
   * @memberof CoreIOStrategy
   */
  downloadMode?: IOStrategyDownloadMode;
  /**
   *
   * @type {IOStrategyUploadMode}
   * @memberof CoreIOStrategy
   */
  uploadMode?: IOStrategyUploadMode;
}

/**
 * Encapsulation of fields that uniquely identifies a Flyte resource.
 * @export
 * @interface CoreIdentifier
 */
export interface CoreIdentifier {
  /**
   * Identifies the specific type of resource that this identifier corresponds to.
   * @type {CoreResourceType}
   * @memberof CoreIdentifier
   */
  resourceType?: CoreResourceType;
  /**
   * Name of the project the resource belongs to.
   * @type {string}
   * @memberof CoreIdentifier
   */
  project?: string;
  /**
   * Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @type {string}
   * @memberof CoreIdentifier
   */
  domain?: string;
  /**
   * User provided value for the resource.
   * @type {string}
   * @memberof CoreIdentifier
   */
  name?: string;
  /**
   * Specific version of the resource.
   * @type {string}
   * @memberof CoreIdentifier
   */
  version?: string;
}

/**
 * Identity encapsulates the various security identities a task can run as. It's up to the underlying plugin to pick the right identity for the execution environment.
 * @export
 * @interface CoreIdentity
 */
export interface CoreIdentity {
  /**
   * iam_role references the fully qualified name of Identity & Access Management role to impersonate.
   * @type {string}
   * @memberof CoreIdentity
   */
  iamRole?: string;
  /**
   * k8s_service_account references a kubernetes service account to impersonate.
   * @type {string}
   * @memberof CoreIdentity
   */
  k8sServiceAccount?: string;
  /**
   * oauth2_client references an oauth2 client. Backend plugins can use this information to impersonate the client when making external calls.
   * @type {CoreOAuth2Client}
   * @memberof CoreIdentity
   */
  oauth2Client?: CoreOAuth2Client;
  /**
   *
   * @type {string}
   * @memberof CoreIdentity
   */
  executionIdentity?: string;
}

/**
 * Defines a condition and the execution unit that should be executed if the condition is satisfied.
 * @export
 * @interface CoreIfBlock
 */
export interface CoreIfBlock {
  /**
   *
   * @type {CoreBooleanExpression}
   * @memberof CoreIfBlock
   */
  condition?: CoreBooleanExpression;
  /**
   *
   * @type {CoreNode}
   * @memberof CoreIfBlock
   */
  thenNode?: CoreNode;
}

/**
 * Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute. If no conditions were satisfied, the else_node or the error will execute.
 * @export
 * @interface CoreIfElseBlock
 */
export interface CoreIfElseBlock {
  /**
   * +required. First condition to evaluate.
   * @type {CoreIfBlock}
   * @memberof CoreIfElseBlock
   */
  _case?: CoreIfBlock;
  /**
   * +optional. Additional branches to evaluate.
   * @type {Array<CoreIfBlock>}
   * @memberof CoreIfElseBlock
   */
  other?: Array<CoreIfBlock>;
  /**
   * The node to execute in case none of the branches were taken.
   * @type {CoreNode}
   * @memberof CoreIfElseBlock
   */
  elseNode?: CoreNode;
  /**
   * An error to throw in case none of the branches were taken.
   * @type {CoreError}
   * @memberof CoreIfElseBlock
   */
  error?: CoreError;
}

/**
 * Metadata for building a kubernetes object when a task is executed.
 * @export
 * @interface CoreK8sObjectMetadata
 */
export interface CoreK8sObjectMetadata {
  /**
   * Optional labels to add to the pod definition.
   * @type {{ [key: string]: string; }}
   * @memberof CoreK8sObjectMetadata
   */
  labels?: { [key: string]: string };
  /**
   * Optional annotations to add to the pod definition.
   * @type {{ [key: string]: string; }}
   * @memberof CoreK8sObjectMetadata
   */
  annotations?: { [key: string]: string };
}

/**
 * Defines a pod spec and additional pod metadata that is created when a task is executed.
 * @export
 * @interface CoreK8sPod
 */
export interface CoreK8sPod {
  /**
   * Contains additional metadata for building a kubernetes pod.
   * @type {CoreK8sObjectMetadata}
   * @memberof CoreK8sPod
   */
  metadata?: CoreK8sObjectMetadata;
  /**
   *
   * @type {ProtobufStruct}
   * @memberof CoreK8sPod
   */
  podSpec?: ProtobufStruct;
  /**
   *
   * @type {CoreDataLoadingConfig}
   * @memberof CoreK8sPod
   */
  dataConfig?: CoreDataLoadingConfig;
}

/**
 * A generic key value pair.
 * @export
 * @interface CoreKeyValuePair
 */
export interface CoreKeyValuePair {
  /**
   * required.
   * @type {string}
   * @memberof CoreKeyValuePair
   */
  key?: string;
  /**
   * +optional.
   * @type {string}
   * @memberof CoreKeyValuePair
   */
  value?: string;
}

/**
 * A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives.
 * @export
 * @interface CoreLiteral
 */
export interface CoreLiteral {
  /**
   * A simple value.
   * @type {CoreScalar}
   * @memberof CoreLiteral
   */
  scalar?: CoreScalar;
  /**
   * A collection of literals to allow nesting.
   * @type {CoreLiteralCollection}
   * @memberof CoreLiteral
   */
  collection?: CoreLiteralCollection;
  /**
   * A map of strings to literals.
   * @type {CoreLiteralMap}
   * @memberof CoreLiteral
   */
  map?: CoreLiteralMap;
  /**
   *
   * @type {string}
   * @memberof CoreLiteral
   */
  hash?: string;
}

/**
 * A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
 * @export
 * @interface CoreLiteralCollection
 */
export interface CoreLiteralCollection {
  /**
   *
   * @type {Array<CoreLiteral>}
   * @memberof CoreLiteralCollection
   */
  literals?: Array<CoreLiteral>;
}

/**
 * A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
 * @export
 * @interface CoreLiteralMap
 */
export interface CoreLiteralMap {
  /**
   *
   * @type {{ [key: string]: CoreLiteral; }}
   * @memberof CoreLiteralMap
   */
  literals?: { [key: string]: CoreLiteral };
}

/**
 * Defines a strong type to allow type checking between interfaces.
 * @export
 * @interface CoreLiteralType
 */
export interface CoreLiteralType {
  /**
   * A simple type that can be compared one-to-one with another.
   * @type {CoreSimpleType}
   * @memberof CoreLiteralType
   */
  simple?: CoreSimpleType;
  /**
   * A complex type that requires matching of inner fields.
   * @type {CoreSchemaType}
   * @memberof CoreLiteralType
   */
  schema?: CoreSchemaType;
  /**
   * Defines the type of the value of a collection. Only homogeneous collections are allowed.
   * @type {CoreLiteralType}
   * @memberof CoreLiteralType
   */
  collectionType?: CoreLiteralType;
  /**
   * Defines the type of the value of a map type. The type of the key is always a string.
   * @type {CoreLiteralType}
   * @memberof CoreLiteralType
   */
  mapValueType?: CoreLiteralType;
  /**
   * A blob might have specialized implementation details depending on associated metadata.
   * @type {CoreBlobType}
   * @memberof CoreLiteralType
   */
  blob?: CoreBlobType;
  /**
   * Defines an enum with pre-defined string values.
   * @type {CoreEnumType}
   * @memberof CoreLiteralType
   */
  enumType?: CoreEnumType;
  /**
   *
   * @type {CoreStructuredDatasetType}
   * @memberof CoreLiteralType
   */
  structuredDatasetType?: CoreStructuredDatasetType;
  /**
   * Defines an union type with pre-defined LiteralTypes.
   * @type {CoreUnionType}
   * @memberof CoreLiteralType
   */
  unionType?: CoreUnionType;
  /**
   * This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by consumers to identify special behavior or display extended information for the type.
   * @type {ProtobufStruct}
   * @memberof CoreLiteralType
   */
  metadata?: ProtobufStruct;
  /**
   * This field contains arbitrary data that might have special semantic meaning for the client but does not effect internal flyte behavior.
   * @type {CoreTypeAnnotation}
   * @memberof CoreLiteralType
   */
  annotation?: CoreTypeAnnotation;
  /**
   * Hints to improve type matching.
   * @type {CoreTypeStructure}
   * @memberof CoreLiteralType
   */
  structure?: CoreTypeStructure;
}

/**
 * A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch node.
 * @export
 * @interface CoreNode
 */
export interface CoreNode {
  /**
   * A workflow-level unique identifier that identifies this node in the workflow. 'inputs' and 'outputs' are reserved node ids that cannot be used by other nodes.
   * @type {string}
   * @memberof CoreNode
   */
  id?: string;
  /**
   * Extra metadata about the node.
   * @type {CoreNodeMetadata}
   * @memberof CoreNode
   */
  metadata?: CoreNodeMetadata;
  /**
   * Specifies how to bind the underlying interface's inputs. All required inputs specified in the underlying interface must be fulfilled.
   * @type {Array<CoreBinding>}
   * @memberof CoreNode
   */
  inputs?: Array<CoreBinding>;
  /**
   * +optional Specifies execution dependency for this node ensuring it will only get scheduled to run after all its upstream nodes have completed. This node will have an implicit dependency on any node that appears in inputs field.
   * @type {Array<string>}
   * @memberof CoreNode
   */
  upstreamNodeIds?: Array<string>;
  /**
   * +optional. A node can define aliases for a subset of its outputs. This is particularly useful if different nodes need to conform to the same interface (e.g. all branches in a branch node). Downstream nodes must refer to this nodes outputs using the alias if one's specified.
   * @type {Array<CoreAlias>}
   * @memberof CoreNode
   */
  outputAliases?: Array<CoreAlias>;
  /**
   * Information about the Task to execute in this node.
   * @type {CoreTaskNode}
   * @memberof CoreNode
   */
  taskNode?: CoreTaskNode;
  /**
   * Information about the Workflow to execute in this mode.
   * @type {CoreWorkflowNode}
   * @memberof CoreNode
   */
  workflowNode?: CoreWorkflowNode;
  /**
   * Information about the branch node to evaluate in this node.
   * @type {CoreBranchNode}
   * @memberof CoreNode
   */
  branchNode?: CoreBranchNode;
  /**
   * Information about the condition to evaluate in this node.
   * @type {CoreGateNode}
   * @memberof CoreNode
   */
  gateNode?: CoreGateNode;
  /**
   * Information about the sub-node executions for each value in the list of this nodes inputs values.
   * @type {CoreArrayNode}
   * @memberof CoreNode
   */
  arrayNode?: CoreArrayNode;
}

/**
 * Encapsulation of fields that identify a Flyte node execution entity.
 * @export
 * @interface CoreNodeExecutionIdentifier
 */
export interface CoreNodeExecutionIdentifier {
  /**
   *
   * @type {string}
   * @memberof CoreNodeExecutionIdentifier
   */
  nodeId?: string;
  /**
   *
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof CoreNodeExecutionIdentifier
   */
  executionId?: CoreWorkflowExecutionIdentifier;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum CoreNodeExecutionPhase {
  UNDEFINED = <any>"UNDEFINED",
  QUEUED = <any>"QUEUED",
  RUNNING = <any>"RUNNING",
  SUCCEEDED = <any>"SUCCEEDED",
  FAILING = <any>"FAILING",
  FAILED = <any>"FAILED",
  ABORTED = <any>"ABORTED",
  SKIPPED = <any>"SKIPPED",
  TIMEDOUT = <any>"TIMED_OUT",
  DYNAMICRUNNING = <any>"DYNAMIC_RUNNING",
  RECOVERED = <any>"RECOVERED",
}

/**
 * Defines extra information about the Node.
 * @export
 * @interface CoreNodeMetadata
 */
export interface CoreNodeMetadata {
  /**
   *
   * @type {string}
   * @memberof CoreNodeMetadata
   */
  name?: string;
  /**
   * The overall timeout of a task.
   * @type {string}
   * @memberof CoreNodeMetadata
   */
  timeout?: string;
  /**
   * Number of retries per task.
   * @type {CoreRetryStrategy}
   * @memberof CoreNodeMetadata
   */
  retries?: CoreRetryStrategy;
  /**
   *
   * @type {boolean}
   * @memberof CoreNodeMetadata
   */
  interruptible?: boolean;
}

/**
 * OAuth2Client encapsulates OAuth2 Client Credentials to be used when making calls on behalf of that task.
 * @export
 * @interface CoreOAuth2Client
 */
export interface CoreOAuth2Client {
  /**
   *
   * @type {string}
   * @memberof CoreOAuth2Client
   */
  clientId?: string;
  /**
   *
   * @type {CoreSecret}
   * @memberof CoreOAuth2Client
   */
  clientSecret?: CoreSecret;
}

/**
 * OAuth2TokenRequest encapsulates information needed to request an OAuth2 token. FLYTE_TOKENS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if tokens are passed through environment variables. FLYTE_TOKENS_PATH_PREFIX will be passed to indicate the prefix of the path where secrets will be mounted if tokens are passed through file mounts.
 * @export
 * @interface CoreOAuth2TokenRequest
 */
export interface CoreOAuth2TokenRequest {
  /**
   *
   * @type {string}
   * @memberof CoreOAuth2TokenRequest
   */
  name?: string;
  /**
   *
   * @type {CoreOAuth2TokenRequestType}
   * @memberof CoreOAuth2TokenRequest
   */
  type?: CoreOAuth2TokenRequestType;
  /**
   *
   * @type {CoreOAuth2Client}
   * @memberof CoreOAuth2TokenRequest
   */
  client?: CoreOAuth2Client;
  /**
   *
   * @type {string}
   * @memberof CoreOAuth2TokenRequest
   */
  idpDiscoveryEndpoint?: string;
  /**
   *
   * @type {string}
   * @memberof CoreOAuth2TokenRequest
   */
  tokenEndpoint?: string;
}

/**
 * Type of the token requested.   - CLIENT_CREDENTIALS: CLIENT_CREDENTIALS indicates a 2-legged OAuth token requested using client credentials.
 * @export
 * @enum {string}
 */
export enum CoreOAuth2TokenRequestType {
  CLIENTCREDENTIALS = <any>"CLIENT_CREDENTIALS",
}

/**
 * Defines an operand to a comparison expression.
 * @export
 * @interface CoreOperand
 */
export interface CoreOperand {
  /**
   *
   * @type {CorePrimitive}
   * @memberof CoreOperand
   */
  primitive?: CorePrimitive;
  /**
   *
   * @type {string}
   * @memberof CoreOperand
   */
  _var?: string;
  /**
   *
   * @type {CoreScalar}
   * @memberof CoreOperand
   */
  scalar?: CoreScalar;
}

/**
 * A reference to an output produced by a node. The type can be retrieved -and validated- from the underlying interface of the node.
 * @export
 * @interface CoreOutputReference
 */
export interface CoreOutputReference {
  /**
   * Node id must exist at the graph layer.
   * @type {string}
   * @memberof CoreOutputReference
   */
  nodeId?: string;
  /**
   * Variable name must refer to an output variable for the node.
   * @type {string}
   * @memberof CoreOutputReference
   */
  _var?: string;
  /**
   *
   * @type {Array<CorePromiseAttribute>}
   * @memberof CoreOutputReference
   */
  attrPath?: Array<CorePromiseAttribute>;
}

/**
 * A parameter is used as input to a launch plan and has the special ability to have a default value or mark itself as required.
 * @export
 * @interface CoreParameter
 */
export interface CoreParameter {
  /**
   * +required Variable. Defines the type of the variable backing this parameter.
   * @type {CoreVariable}
   * @memberof CoreParameter
   */
  _var?: CoreVariable;
  /**
   * Defines a default value that has to match the variable type defined.
   * @type {CoreLiteral}
   * @memberof CoreParameter
   */
  _default?: CoreLiteral;
  /**
   * +optional, is this value required to be filled.
   * @type {boolean}
   * @memberof CoreParameter
   */
  required?: boolean;
}

/**
 * A map of Parameters.
 * @export
 * @interface CoreParameterMap
 */
export interface CoreParameterMap {
  /**
   * Defines a map of parameter names to parameters.
   * @type {{ [key: string]: CoreParameter; }}
   * @memberof CoreParameterMap
   */
  parameters?: { [key: string]: CoreParameter };
}

/**
 *
 * @export
 * @interface CorePrimitive
 */
export interface CorePrimitive {
  /**
   *
   * @type {string}
   * @memberof CorePrimitive
   */
  integer?: string;
  /**
   *
   * @type {number}
   * @memberof CorePrimitive
   */
  floatValue?: number;
  /**
   *
   * @type {string}
   * @memberof CorePrimitive
   */
  stringValue?: string;
  /**
   *
   * @type {boolean}
   * @memberof CorePrimitive
   */
  _boolean?: boolean;
  /**
   *
   * @type {Date}
   * @memberof CorePrimitive
   */
  datetime?: Date;
  /**
   *
   * @type {string}
   * @memberof CorePrimitive
   */
  duration?: string;
}

/**
 *
 * @export
 * @interface CorePromiseAttribute
 */
export interface CorePromiseAttribute {
  /**
   *
   * @type {string}
   * @memberof CorePromiseAttribute
   */
  stringValue?: string;
  /**
   *
   * @type {number}
   * @memberof CorePromiseAttribute
   */
  intValue?: number;
}

/**
 * Indicates the priority of an execution.
 * @export
 * @interface CoreQualityOfService
 */
export interface CoreQualityOfService {
  /**
   *
   * @type {QualityOfServiceTier}
   * @memberof CoreQualityOfService
   */
  tier?: QualityOfServiceTier;
  /**
   *
   * @type {CoreQualityOfServiceSpec}
   * @memberof CoreQualityOfService
   */
  spec?: CoreQualityOfServiceSpec;
}

/**
 * Represents customized execution run-time attributes.
 * @export
 * @interface CoreQualityOfServiceSpec
 */
export interface CoreQualityOfServiceSpec {
  /**
   * Indicates how much queueing delay an execution can tolerate.
   * @type {string}
   * @memberof CoreQualityOfServiceSpec
   */
  queueingBudget?: string;
}

/**
 * Indicates a resource type within Flyte.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
 * @export
 * @enum {string}
 */
export enum CoreResourceType {
  UNSPECIFIED = <any>"UNSPECIFIED",
  TASK = <any>"TASK",
  WORKFLOW = <any>"WORKFLOW",
  LAUNCHPLAN = <any>"LAUNCH_PLAN",
  DATASET = <any>"DATASET",
}

/**
 * A customizable interface to convey resources requested for a container. This can be interpreted differently for different container engines.
 * @export
 * @interface CoreResources
 */
export interface CoreResources {
  /**
   * The desired set of resources requested. ResourceNames must be unique within the list.
   * @type {Array<ResourcesResourceEntry>}
   * @memberof CoreResources
   */
  requests?: Array<ResourcesResourceEntry>;
  /**
   * Defines a set of bounds (e.g. min/max) within which the task can reliably run. ResourceNames must be unique within the list.
   * @type {Array<ResourcesResourceEntry>}
   * @memberof CoreResources
   */
  limits?: Array<ResourcesResourceEntry>;
}

/**
 * Retry strategy associated with an executable unit.
 * @export
 * @interface CoreRetryStrategy
 */
export interface CoreRetryStrategy {
  /**
   * Number of retries. Retries will be consumed when the job fails with a recoverable error. The number of retries must be less than or equals to 10.
   * @type {number}
   * @memberof CoreRetryStrategy
   */
  retries?: number;
}

/**
 * Runtime information. This is loosely defined to allow for extensibility.
 * @export
 * @interface CoreRuntimeMetadata
 */
export interface CoreRuntimeMetadata {
  /**
   * Type of runtime.
   * @type {RuntimeMetadataRuntimeType}
   * @memberof CoreRuntimeMetadata
   */
  type?: RuntimeMetadataRuntimeType;
  /**
   * Version of the runtime. All versions should be backward compatible. However, certain cases call for version checks to ensure tighter validation or setting expectations.
   * @type {string}
   * @memberof CoreRuntimeMetadata
   */
  version?: string;
  /**
   * +optional It can be used to provide extra information about the runtime (e.g. python, golang... etc.).
   * @type {string}
   * @memberof CoreRuntimeMetadata
   */
  flavor?: string;
}

/**
 *
 * @export
 * @interface CoreScalar
 */
export interface CoreScalar {
  /**
   *
   * @type {CorePrimitive}
   * @memberof CoreScalar
   */
  primitive?: CorePrimitive;
  /**
   *
   * @type {CoreBlob}
   * @memberof CoreScalar
   */
  blob?: CoreBlob;
  /**
   *
   * @type {CoreBinary}
   * @memberof CoreScalar
   */
  binary?: CoreBinary;
  /**
   *
   * @type {CoreSchema}
   * @memberof CoreScalar
   */
  schema?: CoreSchema;
  /**
   *
   * @type {CoreVoid}
   * @memberof CoreScalar
   */
  noneType?: CoreVoid;
  /**
   *
   * @type {CoreError}
   * @memberof CoreScalar
   */
  error?: CoreError;
  /**
   *
   * @type {ProtobufStruct}
   * @memberof CoreScalar
   */
  generic?: ProtobufStruct;
  /**
   *
   * @type {CoreStructuredDataset}
   * @memberof CoreScalar
   */
  structuredDataset?: CoreStructuredDataset;
  /**
   *
   * @type {CoreUnion}
   * @memberof CoreScalar
   */
  union?: CoreUnion;
}

/**
 * A strongly typed schema that defines the interface of data retrieved from the underlying storage medium.
 * @export
 * @interface CoreSchema
 */
export interface CoreSchema {
  /**
   *
   * @type {string}
   * @memberof CoreSchema
   */
  uri?: string;
  /**
   *
   * @type {CoreSchemaType}
   * @memberof CoreSchema
   */
  type?: CoreSchemaType;
}

/**
 * Defines schema columns and types to strongly type-validate schemas interoperability.
 * @export
 * @interface CoreSchemaType
 */
export interface CoreSchemaType {
  /**
   * A list of ordered columns this schema comprises of.
   * @type {Array<SchemaTypeSchemaColumn>}
   * @memberof CoreSchemaType
   */
  columns?: Array<SchemaTypeSchemaColumn>;
}

/**
 * Secret encapsulates information about the secret a task needs to proceed. An environment variable FLYTE_SECRETS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if secrets are passed through environment variables. FLYTE_SECRETS_DEFAULT_DIR will be passed to indicate the prefix of the path where secrets will be mounted if secrets are passed through file mounts.
 * @export
 * @interface CoreSecret
 */
export interface CoreSecret {
  /**
   *
   * @type {string}
   * @memberof CoreSecret
   */
  group?: string;
  /**
   *
   * @type {string}
   * @memberof CoreSecret
   */
  groupVersion?: string;
  /**
   *
   * @type {string}
   * @memberof CoreSecret
   */
  key?: string;
  /**
   *
   * @type {SecretMountType}
   * @memberof CoreSecret
   */
  mountRequirement?: SecretMountType;
}

/**
 * SecurityContext holds security attributes that apply to tasks.
 * @export
 * @interface CoreSecurityContext
 */
export interface CoreSecurityContext {
  /**
   * run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the backend plugin to choose the appropriate identity for the execution engine the task will run on.
   * @type {CoreIdentity}
   * @memberof CoreSecurityContext
   */
  runAs?: CoreIdentity;
  /**
   * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.
   * @type {Array<CoreSecret>}
   * @memberof CoreSecurityContext
   */
  secrets?: Array<CoreSecret>;
  /**
   * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.
   * @type {Array<CoreOAuth2TokenRequest>}
   * @memberof CoreSecurityContext
   */
  tokens?: Array<CoreOAuth2TokenRequest>;
}

/**
 * SignalCondition represents a dependency on an signal.
 * @export
 * @interface CoreSignalCondition
 */
export interface CoreSignalCondition {
  /**
   * A unique identifier for the requested signal.
   * @type {string}
   * @memberof CoreSignalCondition
   */
  signalId?: string;
  /**
   * A type denoting the required value type for this signal.
   * @type {CoreLiteralType}
   * @memberof CoreSignalCondition
   */
  type?: CoreLiteralType;
  /**
   * The variable name for the signal value in this nodes outputs.
   * @type {string}
   * @memberof CoreSignalCondition
   */
  outputVariableName?: string;
}

/**
 * Define a set of simple types.
 * @export
 * @enum {string}
 */
export enum CoreSimpleType {
  NONE = <any>"NONE",
  INTEGER = <any>"INTEGER",
  FLOAT = <any>"FLOAT",
  STRING = <any>"STRING",
  BOOLEAN = <any>"BOOLEAN",
  DATETIME = <any>"DATETIME",
  DURATION = <any>"DURATION",
  BINARY = <any>"BINARY",
  ERROR = <any>"ERROR",
  STRUCT = <any>"STRUCT",
}

/**
 * SleepCondition represents a dependency on waiting for the specified duration.
 * @export
 * @interface CoreSleepCondition
 */
export interface CoreSleepCondition {
  /**
   * The overall duration for this sleep.
   * @type {string}
   * @memberof CoreSleepCondition
   */
  duration?: string;
}

/**
 * Span represents a duration trace of Flyte execution. The id field denotes a Flyte execution entity or an operation which uniquely identifies the Span. The spans attribute allows this Span to be further broken down into more precise definitions.
 * @export
 * @interface CoreSpan
 */
export interface CoreSpan {
  /**
   * start_time defines the instance this span began.
   * @type {Date}
   * @memberof CoreSpan
   */
  startTime?: Date;
  /**
   * end_time defines the instance this span completed.
   * @type {Date}
   * @memberof CoreSpan
   */
  endTime?: Date;
  /**
   * workflow_id is the id of the workflow execution this Span represents.
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof CoreSpan
   */
  workflowId?: CoreWorkflowExecutionIdentifier;
  /**
   * node_id is the id of the node execution this Span represents.
   * @type {CoreNodeExecutionIdentifier}
   * @memberof CoreSpan
   */
  nodeId?: CoreNodeExecutionIdentifier;
  /**
   * task_id is the id of the task execution this Span represents.
   * @type {CoreTaskExecutionIdentifier}
   * @memberof CoreSpan
   */
  taskId?: CoreTaskExecutionIdentifier;
  /**
   * operation_id is the id of a unique operation that this Span represents.
   * @type {string}
   * @memberof CoreSpan
   */
  operationId?: string;
  /**
   * spans defines a collection of Spans that breakdown this execution.
   * @type {Array<CoreSpan>}
   * @memberof CoreSpan
   */
  spans?: Array<CoreSpan>;
}

/**
 * Sql represents a generic sql workload with a statement and dialect.
 * @export
 * @interface CoreSql
 */
export interface CoreSql {
  /**
   *
   * @type {string}
   * @memberof CoreSql
   */
  statement?: string;
  /**
   *
   * @type {SqlDialect}
   * @memberof CoreSql
   */
  dialect?: SqlDialect;
}

/**
 *
 * @export
 * @interface CoreStructuredDataset
 */
export interface CoreStructuredDataset {
  /**
   *
   * @type {string}
   * @memberof CoreStructuredDataset
   */
  uri?: string;
  /**
   *
   * @type {CoreStructuredDatasetMetadata}
   * @memberof CoreStructuredDataset
   */
  metadata?: CoreStructuredDatasetMetadata;
}

/**
 *
 * @export
 * @interface CoreStructuredDatasetMetadata
 */
export interface CoreStructuredDatasetMetadata {
  /**
   * Bundle the type information along with the literal. This is here because StructuredDatasets can often be more defined at run time than at compile time. That is, at compile time you might only declare a task to return a pandas dataframe or a StructuredDataset, without any column information, but at run time, you might have that column information. flytekit python will copy this type information into the literal, from the type information, if not provided by the various plugins (encoders). Since this field is run time generated, it's not used for any type checking.
   * @type {CoreStructuredDatasetType}
   * @memberof CoreStructuredDatasetMetadata
   */
  structuredDatasetType?: CoreStructuredDatasetType;
}

/**
 *
 * @export
 * @interface CoreStructuredDatasetType
 */
export interface CoreStructuredDatasetType {
  /**
   * A list of ordered columns this schema comprises of.
   * @type {Array<StructuredDatasetTypeDatasetColumn>}
   * @memberof CoreStructuredDatasetType
   */
  columns?: Array<StructuredDatasetTypeDatasetColumn>;
  /**
   * This is the storage format, the format of the bits at rest parquet, feather, csv, etc. For two types to be compatible, the format will need to be an exact match.
   * @type {string}
   * @memberof CoreStructuredDatasetType
   */
  format?: string;
  /**
   * This is a string representing the type that the bytes in external_schema_bytes are formatted in. This is an optional field that will not be used for type checking.
   * @type {string}
   * @memberof CoreStructuredDatasetType
   */
  externalSchemaType?: string;
  /**
   * The serialized bytes of a third-party schema library like Arrow. This is an optional field that will not be used for type checking.
   * @type {string}
   * @memberof CoreStructuredDatasetType
   */
  externalSchemaBytes?: string;
}

/**
 * Encapsulation of fields that identify a Flyte task execution entity.
 * @export
 * @interface CoreTaskExecutionIdentifier
 */
export interface CoreTaskExecutionIdentifier {
  /**
   *
   * @type {CoreIdentifier}
   * @memberof CoreTaskExecutionIdentifier
   */
  taskId?: CoreIdentifier;
  /**
   *
   * @type {CoreNodeExecutionIdentifier}
   * @memberof CoreTaskExecutionIdentifier
   */
  nodeExecutionId?: CoreNodeExecutionIdentifier;
  /**
   *
   * @type {number}
   * @memberof CoreTaskExecutionIdentifier
   */
  retryAttempt?: number;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum CoreTaskExecutionPhase {
  UNDEFINED = <any>"UNDEFINED",
  QUEUED = <any>"QUEUED",
  RUNNING = <any>"RUNNING",
  SUCCEEDED = <any>"SUCCEEDED",
  ABORTED = <any>"ABORTED",
  FAILED = <any>"FAILED",
  INITIALIZING = <any>"INITIALIZING",
  WAITINGFORRESOURCES = <any>"WAITING_FOR_RESOURCES",
}

/**
 *
 * @export
 * @interface CoreTaskLog
 */
export interface CoreTaskLog {
  /**
   *
   * @type {string}
   * @memberof CoreTaskLog
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof CoreTaskLog
   */
  name?: string;
  /**
   *
   * @type {TaskLogMessageFormat}
   * @memberof CoreTaskLog
   */
  messageFormat?: TaskLogMessageFormat;
  /**
   *
   * @type {string}
   * @memberof CoreTaskLog
   */
  ttl?: string;
}

/**
 *
 * @export
 * @interface CoreTaskMetadata
 */
export interface CoreTaskMetadata {
  /**
   * Indicates whether the system should attempt to lookup this task's output to avoid duplication of work.
   * @type {boolean}
   * @memberof CoreTaskMetadata
   */
  discoverable?: boolean;
  /**
   * Runtime information about the task.
   * @type {CoreRuntimeMetadata}
   * @memberof CoreTaskMetadata
   */
  runtime?: CoreRuntimeMetadata;
  /**
   * The overall timeout of a task including user-triggered retries.
   * @type {string}
   * @memberof CoreTaskMetadata
   */
  timeout?: string;
  /**
   * Number of retries per task.
   * @type {CoreRetryStrategy}
   * @memberof CoreTaskMetadata
   */
  retries?: CoreRetryStrategy;
  /**
   * Indicates a logical version to apply to this task for the purpose of discovery.
   * @type {string}
   * @memberof CoreTaskMetadata
   */
  discoveryVersion?: string;
  /**
   * If set, this indicates that this task is deprecated.  This will enable owners of tasks to notify consumers of the ending of support for a given task.
   * @type {string}
   * @memberof CoreTaskMetadata
   */
  deprecatedErrorMessage?: string;
  /**
   *
   * @type {boolean}
   * @memberof CoreTaskMetadata
   */
  interruptible?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CoreTaskMetadata
   */
  cacheSerializable?: boolean;
  /**
   * Indicates whether the task will generate a Deck URI when it finishes executing.
   * @type {boolean}
   * @memberof CoreTaskMetadata
   */
  generatesDeck?: boolean;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CoreTaskMetadata
   */
  tags?: { [key: string]: string };
  /**
   * pod_template_name is the unique name of a PodTemplate k8s resource to be used as the base configuration if this task creates a k8s Pod. If this value is set, the specified PodTemplate will be used instead of, but applied identically as, the default PodTemplate configured in FlytePropeller.
   * @type {string}
   * @memberof CoreTaskMetadata
   */
  podTemplateName?: string;
}

/**
 * Refers to the task that the Node is to execute.
 * @export
 * @interface CoreTaskNode
 */
export interface CoreTaskNode {
  /**
   * A globally unique identifier for the task.
   * @type {CoreIdentifier}
   * @memberof CoreTaskNode
   */
  referenceId?: CoreIdentifier;
  /**
   * Optional overrides applied at task execution time.
   * @type {CoreTaskNodeOverrides}
   * @memberof CoreTaskNode
   */
  overrides?: CoreTaskNodeOverrides;
}

/**
 * Optional task node overrides that will be applied at task execution time.
 * @export
 * @interface CoreTaskNodeOverrides
 */
export interface CoreTaskNodeOverrides {
  /**
   * A customizable interface to convey resources requested for a task container.
   * @type {CoreResources}
   * @memberof CoreTaskNodeOverrides
   */
  resources?: CoreResources;
  /**
   * Overrides for all non-standard resources, not captured by v1.ResourceRequirements, to allocate to a task.
   * @type {CoreExtendedResources}
   * @memberof CoreTaskNodeOverrides
   */
  extendedResources?: CoreExtendedResources;
}

/**
 * A Task structure that uniquely identifies a task in the system Tasks are registered as a first step in the system.
 * @export
 * @interface CoreTaskTemplate
 */
export interface CoreTaskTemplate {
  /**
   * Auto generated taskId by the system. Task Id uniquely identifies this task globally.
   * @type {CoreIdentifier}
   * @memberof CoreTaskTemplate
   */
  id?: CoreIdentifier;
  /**
   * A predefined yet extensible Task type identifier. This can be used to customize any of the components. If no extensions are provided in the system, Flyte will resolve the this task to its TaskCategory and default the implementation registered for the TaskCategory.
   * @type {string}
   * @memberof CoreTaskTemplate
   */
  type?: string;
  /**
   * Extra metadata about the task.
   * @type {CoreTaskMetadata}
   * @memberof CoreTaskTemplate
   */
  metadata?: CoreTaskMetadata;
  /**
   * A strongly typed interface for the task. This enables others to use this task within a workflow and guarantees compile-time validation of the workflow to avoid costly runtime failures.
   * @type {CoreTypedInterface}
   * @memberof CoreTaskTemplate
   */
  _interface?: CoreTypedInterface;
  /**
   * Custom data about the task. This is extensible to allow various plugins in the system.
   * @type {ProtobufStruct}
   * @memberof CoreTaskTemplate
   */
  custom?: ProtobufStruct;
  /**
   *
   * @type {CoreContainer}
   * @memberof CoreTaskTemplate
   */
  container?: CoreContainer;
  /**
   *
   * @type {CoreK8sPod}
   * @memberof CoreTaskTemplate
   */
  k8sPod?: CoreK8sPod;
  /**
   *
   * @type {CoreSql}
   * @memberof CoreTaskTemplate
   */
  sql?: CoreSql;
  /**
   * This can be used to customize task handling at execution time for the same task type.
   * @type {number}
   * @memberof CoreTaskTemplate
   */
  taskTypeVersion?: number;
  /**
   * security_context encapsulates security attributes requested to run this task.
   * @type {CoreSecurityContext}
   * @memberof CoreTaskTemplate
   */
  securityContext?: CoreSecurityContext;
  /**
   * Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to allocate to a task.
   * @type {CoreExtendedResources}
   * @memberof CoreTaskTemplate
   */
  extendedResources?: CoreExtendedResources;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CoreTaskTemplate
   */
  config?: { [key: string]: string };
}

/**
 * TypeAnnotation encapsulates registration time information about a type. This can be used for various control-plane operations. TypeAnnotation will not be available at runtime when a task runs.
 * @export
 * @interface CoreTypeAnnotation
 */
export interface CoreTypeAnnotation {
  /**
   * A arbitrary JSON payload to describe a type.
   * @type {ProtobufStruct}
   * @memberof CoreTypeAnnotation
   */
  annotations?: ProtobufStruct;
}

/**
 * Hints to improve type matching e.g. allows distinguishing output from custom type transformers even if the underlying IDL serialization matches.
 * @export
 * @interface CoreTypeStructure
 */
export interface CoreTypeStructure {
  /**
   *
   * @type {string}
   * @memberof CoreTypeStructure
   */
  tag?: string;
  /**
   *
   * @type {{ [key: string]: CoreLiteralType; }}
   * @memberof CoreTypeStructure
   */
  dataclassType?: { [key: string]: CoreLiteralType };
}

/**
 * Defines strongly typed inputs and outputs.
 * @export
 * @interface CoreTypedInterface
 */
export interface CoreTypedInterface {
  /**
   *
   * @type {CoreVariableMap}
   * @memberof CoreTypedInterface
   */
  inputs?: CoreVariableMap;
  /**
   *
   * @type {CoreVariableMap}
   * @memberof CoreTypedInterface
   */
  outputs?: CoreVariableMap;
}

/**
 * The runtime representation of a tagged union value. See `UnionType` for more details.
 * @export
 * @interface CoreUnion
 */
export interface CoreUnion {
  /**
   *
   * @type {CoreLiteral}
   * @memberof CoreUnion
   */
  value?: CoreLiteral;
  /**
   *
   * @type {CoreLiteralType}
   * @memberof CoreUnion
   */
  type?: CoreLiteralType;
}

/**
 *
 * @export
 * @interface CoreUnionInfo
 */
export interface CoreUnionInfo {
  /**
   *
   * @type {CoreLiteralType}
   * @memberof CoreUnionInfo
   */
  targetType?: CoreLiteralType;
}

/**
 * Defines a tagged union type, also known as a variant (and formally as the sum type).  A sum type S is defined by a sequence of types (A, B, C, ...), each tagged by a string tag A value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by storing the varaint's tag with the literal value and can be examined in runtime.  Type S is typically written as S := Apple A | Banana B | Cantaloupe C | ...  Notably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value: Optional X := X | Null  See also: https://en.wikipedia.org/wiki/Tagged_union
 * @export
 * @interface CoreUnionType
 */
export interface CoreUnionType {
  /**
   * Predefined set of variants in union.
   * @type {Array<CoreLiteralType>}
   * @memberof CoreUnionType
   */
  variants?: Array<CoreLiteralType>;
}

/**
 * Defines a strongly typed variable.
 * @export
 * @interface CoreVariable
 */
export interface CoreVariable {
  /**
   * Variable literal type.
   * @type {CoreLiteralType}
   * @memberof CoreVariable
   */
  type?: CoreLiteralType;
  /**
   *
   * @type {string}
   * @memberof CoreVariable
   */
  description?: string;
}

/**
 *
 * @export
 * @interface CoreVariableMap
 */
export interface CoreVariableMap {
  /**
   * Defines a map of variable names to variables.
   * @type {{ [key: string]: CoreVariable; }}
   * @memberof CoreVariableMap
   */
  variables?: { [key: string]: CoreVariable };
}

/**
 * Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally undefined since it can be assigned to a scalar of any LiteralType.
 * @export
 * @interface CoreVoid
 */
export interface CoreVoid {}

/**
 *
 * @export
 * @interface CoreWorkflowExecutionIdentifier
 */
export interface CoreWorkflowExecutionIdentifier {
  /**
   * Name of the project the resource belongs to.
   * @type {string}
   * @memberof CoreWorkflowExecutionIdentifier
   */
  project?: string;
  /**
   * Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @type {string}
   * @memberof CoreWorkflowExecutionIdentifier
   */
  domain?: string;
  /**
   * User or system provided value for the resource.
   * @type {string}
   * @memberof CoreWorkflowExecutionIdentifier
   */
  name?: string;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum CoreWorkflowExecutionPhase {
  UNDEFINED = <any>"UNDEFINED",
  QUEUED = <any>"QUEUED",
  RUNNING = <any>"RUNNING",
  SUCCEEDING = <any>"SUCCEEDING",
  SUCCEEDED = <any>"SUCCEEDED",
  FAILING = <any>"FAILING",
  FAILED = <any>"FAILED",
  ABORTED = <any>"ABORTED",
  TIMEDOUT = <any>"TIMED_OUT",
  ABORTING = <any>"ABORTING",
}

/**
 * This is workflow layer metadata. These settings are only applicable to the workflow as a whole, and do not percolate down to child entities (like tasks) launched by the workflow.
 * @export
 * @interface CoreWorkflowMetadata
 */
export interface CoreWorkflowMetadata {
  /**
   * Indicates the runtime priority of workflow executions.
   * @type {CoreQualityOfService}
   * @memberof CoreWorkflowMetadata
   */
  qualityOfService?: CoreQualityOfService;
  /**
   * Defines how the system should behave when a failure is detected in the workflow execution.
   * @type {WorkflowMetadataOnFailurePolicy}
   * @memberof CoreWorkflowMetadata
   */
  onFailure?: WorkflowMetadataOnFailurePolicy;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CoreWorkflowMetadata
   */
  tags?: { [key: string]: string };
}

/**
 * The difference between these settings and the WorkflowMetadata ones is that these are meant to be passed down to a workflow's underlying entities (like tasks). For instance, 'interruptible' has no meaning at the workflow layer, it is only relevant when a task executes. The settings here are the defaults that are passed to all nodes unless explicitly overridden at the node layer. If you are adding a setting that applies to both the Workflow itself, and everything underneath it, it should be added to both this object and the WorkflowMetadata object above.
 * @export
 * @interface CoreWorkflowMetadataDefaults
 */
export interface CoreWorkflowMetadataDefaults {
  /**
   * Whether child nodes of the workflow are interruptible.
   * @type {boolean}
   * @memberof CoreWorkflowMetadataDefaults
   */
  interruptible?: boolean;
}

/**
 * Refers to a the workflow the node is to execute.
 * @export
 * @interface CoreWorkflowNode
 */
export interface CoreWorkflowNode {
  /**
   * A globally unique identifier for the launch plan.
   * @type {CoreIdentifier}
   * @memberof CoreWorkflowNode
   */
  launchplanRef?: CoreIdentifier;
  /**
   *
   * @type {CoreIdentifier}
   * @memberof CoreWorkflowNode
   */
  subWorkflowRef?: CoreIdentifier;
}

/**
 * Flyte Workflow Structure that encapsulates task, branch and subworkflow nodes to form a statically analyzable, directed acyclic graph.
 * @export
 * @interface CoreWorkflowTemplate
 */
export interface CoreWorkflowTemplate {
  /**
   * A globally unique identifier for the workflow.
   * @type {CoreIdentifier}
   * @memberof CoreWorkflowTemplate
   */
  id?: CoreIdentifier;
  /**
   * Extra metadata about the workflow.
   * @type {CoreWorkflowMetadata}
   * @memberof CoreWorkflowTemplate
   */
  metadata?: CoreWorkflowMetadata;
  /**
   * Defines a strongly typed interface for the Workflow. This can include some optional parameters.
   * @type {CoreTypedInterface}
   * @memberof CoreWorkflowTemplate
   */
  _interface?: CoreTypedInterface;
  /**
   * A list of nodes. In addition, 'globals' is a special reserved node id that can be used to consume workflow inputs.
   * @type {Array<CoreNode>}
   * @memberof CoreWorkflowTemplate
   */
  nodes?: Array<CoreNode>;
  /**
   * A list of output bindings that specify how to construct workflow outputs. Bindings can pull node outputs or specify literals. All workflow outputs specified in the interface field must be bound in order for the workflow to be validated. A workflow has an implicit dependency on all of its nodes to execute successfully in order to bind final outputs. Most of these outputs will be Binding's with a BindingData of type OutputReference.  That is, your workflow can just have an output of some constant (`Output(5)`), but usually, the workflow will be pulling outputs from the output of a task.
   * @type {Array<CoreBinding>}
   * @memberof CoreWorkflowTemplate
   */
  outputs?: Array<CoreBinding>;
  /**
   * +optional A catch-all node. This node is executed whenever the execution engine determines the workflow has failed. The interface of this node must match the Workflow interface with an additional input named 'error' of type pb.lyft.flyte.core.Error.
   * @type {CoreNode}
   * @memberof CoreWorkflowTemplate
   */
  failureNode?: CoreNode;
  /**
   *
   * @type {CoreWorkflowMetadataDefaults}
   * @memberof CoreWorkflowTemplate
   */
  metadataDefaults?: CoreWorkflowMetadataDefaults;
}

/**
 * - JSON: JSON / YAML for the metadata (which contains inlined primitive values). The representation is inline with the standard json specification as specified - https://www.json.org/json-en.html  - PROTO: Proto is a serialized binary of `core.LiteralMap` defined in flyteidl/core
 * @export
 * @enum {string}
 */
export enum DataLoadingConfigLiteralMapFormat {
  JSON = <any>"JSON",
  YAML = <any>"YAML",
  PROTO = <any>"PROTO",
}

/**
 *
 * @export
 * @interface EventEventReason
 */
export interface EventEventReason {
  /**
   *
   * @type {string}
   * @memberof EventEventReason
   */
  reason?: string;
  /**
   *
   * @type {Date}
   * @memberof EventEventReason
   */
  occurredAt?: Date;
}

/**
 * This message contains metadata about external resources produced or used by a specific task execution.
 * @export
 * @interface EventExternalResourceInfo
 */
export interface EventExternalResourceInfo {
  /**
   * Identifier for an external resource created by this task execution, for example Qubole query ID or presto query ids.
   * @type {string}
   * @memberof EventExternalResourceInfo
   */
  externalId?: string;
  /**
   * A unique index for the external resource with respect to all external resources for this task. Although the identifier may change between task reporting events or retries, this will remain the same to enable aggregating information from multiple reports.
   * @type {number}
   * @memberof EventExternalResourceInfo
   */
  index?: number;
  /**
   *
   * @type {number}
   * @memberof EventExternalResourceInfo
   */
  retryAttempt?: number;
  /**
   *
   * @type {CoreTaskExecutionPhase}
   * @memberof EventExternalResourceInfo
   */
  phase?: CoreTaskExecutionPhase;
  /**
   * Captures the status of caching for this external resource execution.
   * @type {CoreCatalogCacheStatus}
   * @memberof EventExternalResourceInfo
   */
  cacheStatus?: CoreCatalogCacheStatus;
  /**
   *
   * @type {Array<CoreTaskLog>}
   * @memberof EventExternalResourceInfo
   */
  logs?: Array<CoreTaskLog>;
}

/**
 *
 * @export
 * @interface EventNodeExecutionEvent
 */
export interface EventNodeExecutionEvent {
  /**
   *
   * @type {CoreNodeExecutionIdentifier}
   * @memberof EventNodeExecutionEvent
   */
  id?: CoreNodeExecutionIdentifier;
  /**
   *
   * @type {string}
   * @memberof EventNodeExecutionEvent
   */
  producerId?: string;
  /**
   *
   * @type {CoreNodeExecutionPhase}
   * @memberof EventNodeExecutionEvent
   */
  phase?: CoreNodeExecutionPhase;
  /**
   * This timestamp represents when the original event occurred, it is generated by the executor of the node.
   * @type {Date}
   * @memberof EventNodeExecutionEvent
   */
  occurredAt?: Date;
  /**
   *
   * @type {string}
   * @memberof EventNodeExecutionEvent
   */
  inputUri?: string;
  /**
   * Raw input data consumed by this node execution.
   * @type {CoreLiteralMap}
   * @memberof EventNodeExecutionEvent
   */
  inputData?: CoreLiteralMap;
  /**
   * URL to the output of the execution, it encodes all the information including Cloud source provider. ie., s3://...
   * @type {string}
   * @memberof EventNodeExecutionEvent
   */
  outputUri?: string;
  /**
   *
   * @type {CoreExecutionError}
   * @memberof EventNodeExecutionEvent
   */
  error?: CoreExecutionError;
  /**
   * Raw output data produced by this node execution.
   * @type {CoreLiteralMap}
   * @memberof EventNodeExecutionEvent
   */
  outputData?: CoreLiteralMap;
  /**
   *
   * @type {FlyteidleventWorkflowNodeMetadata}
   * @memberof EventNodeExecutionEvent
   */
  workflowNodeMetadata?: FlyteidleventWorkflowNodeMetadata;
  /**
   *
   * @type {FlyteidleventTaskNodeMetadata}
   * @memberof EventNodeExecutionEvent
   */
  taskNodeMetadata?: FlyteidleventTaskNodeMetadata;
  /**
   * [To be deprecated] Specifies which task (if any) launched this node.
   * @type {EventParentTaskExecutionMetadata}
   * @memberof EventNodeExecutionEvent
   */
  parentTaskMetadata?: EventParentTaskExecutionMetadata;
  /**
   * Specifies the parent node of the current node execution. Node executions at level zero will not have a parent node.
   * @type {EventParentNodeExecutionMetadata}
   * @memberof EventNodeExecutionEvent
   */
  parentNodeMetadata?: EventParentNodeExecutionMetadata;
  /**
   *
   * @type {string}
   * @memberof EventNodeExecutionEvent
   */
  retryGroup?: string;
  /**
   *
   * @type {string}
   * @memberof EventNodeExecutionEvent
   */
  specNodeId?: string;
  /**
   *
   * @type {string}
   * @memberof EventNodeExecutionEvent
   */
  nodeName?: string;
  /**
   *
   * @type {number}
   * @memberof EventNodeExecutionEvent
   */
  eventVersion?: number;
  /**
   * Whether this node launched a subworkflow.
   * @type {boolean}
   * @memberof EventNodeExecutionEvent
   */
  isParent?: boolean;
  /**
   * Whether this node yielded a dynamic workflow.
   * @type {boolean}
   * @memberof EventNodeExecutionEvent
   */
  isDynamic?: boolean;
  /**
   *
   * @type {string}
   * @memberof EventNodeExecutionEvent
   */
  deckUri?: string;
  /**
   * This timestamp represents the instant when the event was reported by the executing framework. For example, when first processing a node the `occurred_at` timestamp should be the instant propeller makes progress, so when literal inputs are initially copied. The event however will not be sent until after the copy completes. Extracting both of these timestamps facilitates a more accurate portrayal of the evaluation time-series.
   * @type {Date}
   * @memberof EventNodeExecutionEvent
   */
  reportedAt?: Date;
  /**
   * Indicates if this node is an ArrayNode.
   * @type {boolean}
   * @memberof EventNodeExecutionEvent
   */
  isArray?: boolean;
}

/**
 *
 * @export
 * @interface EventParentNodeExecutionMetadata
 */
export interface EventParentNodeExecutionMetadata {
  /**
   *
   * @type {string}
   * @memberof EventParentNodeExecutionMetadata
   */
  nodeId?: string;
}

/**
 *
 * @export
 * @interface EventParentTaskExecutionMetadata
 */
export interface EventParentTaskExecutionMetadata {
  /**
   *
   * @type {CoreTaskExecutionIdentifier}
   * @memberof EventParentTaskExecutionMetadata
   */
  id?: CoreTaskExecutionIdentifier;
}

/**
 * This message holds task execution metadata specific to resource allocation used to manage concurrent executions for a project namespace.
 * @export
 * @interface EventResourcePoolInfo
 */
export interface EventResourcePoolInfo {
  /**
   * Unique resource ID used to identify this execution when allocating a token.
   * @type {string}
   * @memberof EventResourcePoolInfo
   */
  allocationToken?: string;
  /**
   * Namespace under which this task execution requested an allocation token.
   * @type {string}
   * @memberof EventResourcePoolInfo
   */
  namespace?: string;
}

/**
 * Plugin specific execution event information. For tasks like Python, Hive, Spark, DynamicJob.
 * @export
 * @interface EventTaskExecutionEvent
 */
export interface EventTaskExecutionEvent {
  /**
   * ID of the task. In combination with the retryAttempt this will indicate the task execution uniquely for a given parent node execution.
   * @type {CoreIdentifier}
   * @memberof EventTaskExecutionEvent
   */
  taskId?: CoreIdentifier;
  /**
   *
   * @type {CoreNodeExecutionIdentifier}
   * @memberof EventTaskExecutionEvent
   */
  parentNodeExecutionId?: CoreNodeExecutionIdentifier;
  /**
   *
   * @type {number}
   * @memberof EventTaskExecutionEvent
   */
  retryAttempt?: number;
  /**
   *
   * @type {CoreTaskExecutionPhase}
   * @memberof EventTaskExecutionEvent
   */
  phase?: CoreTaskExecutionPhase;
  /**
   *
   * @type {string}
   * @memberof EventTaskExecutionEvent
   */
  producerId?: string;
  /**
   *
   * @type {Array<CoreTaskLog>}
   * @memberof EventTaskExecutionEvent
   */
  logs?: Array<CoreTaskLog>;
  /**
   * This timestamp represents when the original event occurred, it is generated by the executor of the task.
   * @type {Date}
   * @memberof EventTaskExecutionEvent
   */
  occurredAt?: Date;
  /**
   * URI of the input file, it encodes all the information including Cloud source provider. ie., s3://...
   * @type {string}
   * @memberof EventTaskExecutionEvent
   */
  inputUri?: string;
  /**
   * Raw input data consumed by this task execution.
   * @type {CoreLiteralMap}
   * @memberof EventTaskExecutionEvent
   */
  inputData?: CoreLiteralMap;
  /**
   * URI to the output of the execution, it will be in a format that encodes all the information including Cloud source provider. ie., s3://...
   * @type {string}
   * @memberof EventTaskExecutionEvent
   */
  outputUri?: string;
  /**
   *
   * @type {CoreExecutionError}
   * @memberof EventTaskExecutionEvent
   */
  error?: CoreExecutionError;
  /**
   * Raw output data produced by this task execution.
   * @type {CoreLiteralMap}
   * @memberof EventTaskExecutionEvent
   */
  outputData?: CoreLiteralMap;
  /**
   * Custom data that the task plugin sends back. This is extensible to allow various plugins in the system.
   * @type {ProtobufStruct}
   * @memberof EventTaskExecutionEvent
   */
  customInfo?: ProtobufStruct;
  /**
   * Some phases, like RUNNING, can send multiple events with changed metadata (new logs, additional custom_info, etc) that should be recorded regardless of the lack of phase change. The version field should be incremented when metadata changes across the duration of an individual phase.
   * @type {number}
   * @memberof EventTaskExecutionEvent
   */
  phaseVersion?: number;
  /**
   * An optional explanation for the phase transition. Deprecated: Use reasons instead.
   * @type {string}
   * @memberof EventTaskExecutionEvent
   */
  reason?: string;
  /**
   * An optional list of explanations for the phase transition.
   * @type {Array<EventEventReason>}
   * @memberof EventTaskExecutionEvent
   */
  reasons?: Array<EventEventReason>;
  /**
   * A predefined yet extensible Task type identifier. If the task definition is already registered in flyte admin this type will be identical, but not all task executions necessarily use pre-registered definitions and this type is useful to render the task in the UI, filter task executions, etc.
   * @type {string}
   * @memberof EventTaskExecutionEvent
   */
  taskType?: string;
  /**
   * Metadata around how a task was executed.
   * @type {FlyteidleventTaskExecutionMetadata}
   * @memberof EventTaskExecutionEvent
   */
  metadata?: FlyteidleventTaskExecutionMetadata;
  /**
   * The event version is used to indicate versioned changes in how data is reported using this proto message. For example, event_verison > 0 means that maps tasks report logs using the TaskExecutionMetadata ExternalResourceInfo fields for each subtask rather than the TaskLog in this message.
   * @type {number}
   * @memberof EventTaskExecutionEvent
   */
  eventVersion?: number;
  /**
   * This timestamp represents the instant when the event was reported by the executing framework. For example, a k8s pod task may be marked completed at (ie. `occurred_at`) the instant the container running user code completes, but this event will not be reported until the pod is marked as completed. Extracting both of these timestamps facilitates a more accurate portrayal of the evaluation time-series.
   * @type {Date}
   * @memberof EventTaskExecutionEvent
   */
  reportedAt?: Date;
}

/**
 *
 * @export
 * @interface EventWorkflowExecutionEvent
 */
export interface EventWorkflowExecutionEvent {
  /**
   *
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof EventWorkflowExecutionEvent
   */
  executionId?: CoreWorkflowExecutionIdentifier;
  /**
   *
   * @type {string}
   * @memberof EventWorkflowExecutionEvent
   */
  producerId?: string;
  /**
   *
   * @type {CoreWorkflowExecutionPhase}
   * @memberof EventWorkflowExecutionEvent
   */
  phase?: CoreWorkflowExecutionPhase;
  /**
   * This timestamp represents when the original event occurred, it is generated by the executor of the workflow.
   * @type {Date}
   * @memberof EventWorkflowExecutionEvent
   */
  occurredAt?: Date;
  /**
   * URL to the output of the execution, it encodes all the information including Cloud source provider. ie., s3://...
   * @type {string}
   * @memberof EventWorkflowExecutionEvent
   */
  outputUri?: string;
  /**
   *
   * @type {CoreExecutionError}
   * @memberof EventWorkflowExecutionEvent
   */
  error?: CoreExecutionError;
  /**
   * Raw output data produced by this workflow execution.
   * @type {CoreLiteralMap}
   * @memberof EventWorkflowExecutionEvent
   */
  outputData?: CoreLiteralMap;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum ExecutionErrorErrorKind {
  UNKNOWN = <any>"UNKNOWN",
  USER = <any>"USER",
  SYSTEM = <any>"SYSTEM",
}

/**
 * The method by which this execution was launched.   - MANUAL: The default execution mode, MANUAL implies that an execution was launched by an individual.  - SCHEDULED: A schedule triggered this execution launch.  - SYSTEM: A system process was responsible for launching this execution rather an individual.  - RELAUNCH: This execution was launched with identical inputs as a previous execution.  - CHILD_WORKFLOW: This execution was triggered by another execution.  - RECOVERED: This execution was recovered from another execution.
 * @export
 * @enum {string}
 */
export enum ExecutionMetadataExecutionMode {
  MANUAL = <any>"MANUAL",
  SCHEDULED = <any>"SCHEDULED",
  SYSTEM = <any>"SYSTEM",
  RELAUNCH = <any>"RELAUNCH",
  CHILDWORKFLOW = <any>"CHILD_WORKFLOW",
  RECOVERED = <any>"RECOVERED",
}

/**
 * For dynamic workflow nodes we capture information about the dynamic workflow definition that gets generated.
 * @export
 * @interface FlyteidladminDynamicWorkflowNodeMetadata
 */
export interface FlyteidladminDynamicWorkflowNodeMetadata {
  /**
   * id represents the unique identifier of the workflow.
   * @type {CoreIdentifier}
   * @memberof FlyteidladminDynamicWorkflowNodeMetadata
   */
  id?: CoreIdentifier;
  /**
   * Represents the compiled representation of the embedded dynamic workflow.
   * @type {CoreCompiledWorkflowClosure}
   * @memberof FlyteidladminDynamicWorkflowNodeMetadata
   */
  compiledWorkflow?: CoreCompiledWorkflowClosure;
  /**
   * dynamic_job_spec_uri is the location of the DynamicJobSpec proto message for this DynamicWorkflow. This is required to correctly recover partially completed executions where the subworkflow has already been compiled.
   * @type {string}
   * @memberof FlyteidladminDynamicWorkflowNodeMetadata
   */
  dynamicJobSpecUri?: string;
}

/**
 * Encapsulates all details for a single node execution entity. A node represents a component in the overall workflow graph. A node launch a task, multiple tasks, an entire nested sub-workflow, or even a separate child-workflow execution. The same task can be called repeatedly in a single workflow but each node is unique.
 * @export
 * @interface FlyteidladminNodeExecution
 */
export interface FlyteidladminNodeExecution {
  /**
   * Uniquely identifies an individual node execution.
   * @type {CoreNodeExecutionIdentifier}
   * @memberof FlyteidladminNodeExecution
   */
  id?: CoreNodeExecutionIdentifier;
  /**
   * Path to remote data store where input blob is stored.
   * @type {string}
   * @memberof FlyteidladminNodeExecution
   */
  inputUri?: string;
  /**
   * Computed results associated with this node execution.
   * @type {AdminNodeExecutionClosure}
   * @memberof FlyteidladminNodeExecution
   */
  closure?: AdminNodeExecutionClosure;
  /**
   *
   * @type {AdminNodeExecutionMetaData}
   * @memberof FlyteidladminNodeExecution
   */
  metadata?: AdminNodeExecutionMetaData;
}

/**
 *
 * @export
 * @interface FlyteidladminTaskCreateRequest
 */
export interface FlyteidladminTaskCreateRequest {
  /**
   *
   * @type {CoreIdentifier}
   * @memberof FlyteidladminTaskCreateRequest
   */
  id?: CoreIdentifier;
  /**
   *
   * @type {AdminTaskSpec}
   * @memberof FlyteidladminTaskCreateRequest
   */
  spec?: AdminTaskSpec;
}

/**
 * Represents a response structure if task creation succeeds.
 * @export
 * @interface FlyteidladminTaskCreateResponse
 */
export interface FlyteidladminTaskCreateResponse {}

/**
 * Encapsulates all details for a single task execution entity. A task execution represents an instantiated task, including all inputs and additional metadata as well as computed results included state, outputs, and duration-based attributes.
 * @export
 * @interface FlyteidladminTaskExecution
 */
export interface FlyteidladminTaskExecution {
  /**
   * Unique identifier for the task execution.
   * @type {CoreTaskExecutionIdentifier}
   * @memberof FlyteidladminTaskExecution
   */
  id?: CoreTaskExecutionIdentifier;
  /**
   * Path to remote data store where input blob is stored.
   * @type {string}
   * @memberof FlyteidladminTaskExecution
   */
  inputUri?: string;
  /**
   * Task execution details and results.
   * @type {AdminTaskExecutionClosure}
   * @memberof FlyteidladminTaskExecution
   */
  closure?: AdminTaskExecutionClosure;
  /**
   * Whether this task spawned nodes.
   * @type {boolean}
   * @memberof FlyteidladminTaskExecution
   */
  isParent?: boolean;
}

/**
 *
 * @export
 * @interface FlyteidladminTaskNodeMetadata
 */
export interface FlyteidladminTaskNodeMetadata {
  /**
   * Captures the status of caching for this execution.
   * @type {CoreCatalogCacheStatus}
   * @memberof FlyteidladminTaskNodeMetadata
   */
  cacheStatus?: CoreCatalogCacheStatus;
  /**
   *
   * @type {CoreCatalogMetadata}
   * @memberof FlyteidladminTaskNodeMetadata
   */
  catalogKey?: CoreCatalogMetadata;
  /**
   *
   * @type {string}
   * @memberof FlyteidladminTaskNodeMetadata
   */
  checkpointUri?: string;
}

/**
 *
 * @export
 * @interface FlyteidladminWorkflowNodeMetadata
 */
export interface FlyteidladminWorkflowNodeMetadata {
  /**
   * The identifier for a workflow execution launched by a node.
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof FlyteidladminWorkflowNodeMetadata
   */
  executionId?: CoreWorkflowExecutionIdentifier;
}

/**
 * For dynamic workflow nodes we send information about the dynamic workflow definition that gets generated.
 * @export
 * @interface FlyteidleventDynamicWorkflowNodeMetadata
 */
export interface FlyteidleventDynamicWorkflowNodeMetadata {
  /**
   * id represents the unique identifier of the workflow.
   * @type {CoreIdentifier}
   * @memberof FlyteidleventDynamicWorkflowNodeMetadata
   */
  id?: CoreIdentifier;
  /**
   * Represents the compiled representation of the embedded dynamic workflow.
   * @type {CoreCompiledWorkflowClosure}
   * @memberof FlyteidleventDynamicWorkflowNodeMetadata
   */
  compiledWorkflow?: CoreCompiledWorkflowClosure;
  /**
   * dynamic_job_spec_uri is the location of the DynamicJobSpec proto message for this DynamicWorkflow. This is required to correctly recover partially completed executions where the workflow has already been compiled.
   * @type {string}
   * @memberof FlyteidleventDynamicWorkflowNodeMetadata
   */
  dynamicJobSpecUri?: string;
}

/**
 * Holds metadata around how a task was executed. As a task transitions across event phases during execution some attributes, such its generated name, generated external resources, and more may grow in size but not change necessarily based on the phase transition that sparked the event update. Metadata is a container for these attributes across the task execution lifecycle.
 * @export
 * @interface FlyteidleventTaskExecutionMetadata
 */
export interface FlyteidleventTaskExecutionMetadata {
  /**
   * Unique, generated name for this task execution used by the backend.
   * @type {string}
   * @memberof FlyteidleventTaskExecutionMetadata
   */
  generatedName?: string;
  /**
   * Additional data on external resources on other back-ends or platforms (e.g. Hive, Qubole, etc) launched by this task execution.
   * @type {Array<EventExternalResourceInfo>}
   * @memberof FlyteidleventTaskExecutionMetadata
   */
  externalResources?: Array<EventExternalResourceInfo>;
  /**
   * Includes additional data on concurrent resource management used during execution.. This is a repeated field because a plugin can request multiple resource allocations during execution.
   * @type {Array<EventResourcePoolInfo>}
   * @memberof FlyteidleventTaskExecutionMetadata
   */
  resourcePoolInfo?: Array<EventResourcePoolInfo>;
  /**
   * The identifier of the plugin used to execute this task.
   * @type {string}
   * @memberof FlyteidleventTaskExecutionMetadata
   */
  pluginIdentifier?: string;
  /**
   *
   * @type {TaskExecutionMetadataInstanceClass}
   * @memberof FlyteidleventTaskExecutionMetadata
   */
  instanceClass?: TaskExecutionMetadataInstanceClass;
}

/**
 *
 * @export
 * @interface FlyteidleventTaskNodeMetadata
 */
export interface FlyteidleventTaskNodeMetadata {
  /**
   * Captures the status of caching for this execution.
   * @type {CoreCatalogCacheStatus}
   * @memberof FlyteidleventTaskNodeMetadata
   */
  cacheStatus?: CoreCatalogCacheStatus;
  /**
   *
   * @type {CoreCatalogMetadata}
   * @memberof FlyteidleventTaskNodeMetadata
   */
  catalogKey?: CoreCatalogMetadata;
  /**
   * Captures the status of cache reservations for this execution.
   * @type {CatalogReservationStatus}
   * @memberof FlyteidleventTaskNodeMetadata
   */
  reservationStatus?: CatalogReservationStatus;
  /**
   *
   * @type {string}
   * @memberof FlyteidleventTaskNodeMetadata
   */
  checkpointUri?: string;
  /**
   * In the case this task launched a dynamic workflow we capture its structure here.
   * @type {FlyteidleventDynamicWorkflowNodeMetadata}
   * @memberof FlyteidleventTaskNodeMetadata
   */
  dynamicWorkflow?: FlyteidleventDynamicWorkflowNodeMetadata;
}

/**
 *
 * @export
 * @interface FlyteidleventWorkflowNodeMetadata
 */
export interface FlyteidleventWorkflowNodeMetadata {
  /**
   *
   * @type {CoreWorkflowExecutionIdentifier}
   * @memberof FlyteidleventWorkflowNodeMetadata
   */
  executionId?: CoreWorkflowExecutionIdentifier;
}

/**
 * - DOWNLOAD_EAGER: All data will be downloaded before the main container is executed  - DOWNLOAD_STREAM: Data will be downloaded as a stream and an End-Of-Stream marker will be written to indicate all data has been downloaded. Refer to protocol for details  - DO_NOT_DOWNLOAD: Large objects (offloaded) will not be downloaded
 * @export
 * @enum {string}
 */
export enum IOStrategyDownloadMode {
  DOWNLOADEAGER = <any>"DOWNLOAD_EAGER",
  DOWNLOADSTREAM = <any>"DOWNLOAD_STREAM",
  DONOTDOWNLOAD = <any>"DO_NOT_DOWNLOAD",
}

/**
 * - UPLOAD_ON_EXIT: All data will be uploaded after the main container exits  - UPLOAD_EAGER: Data will be uploaded as it appears. Refer to protocol specification for details  - DO_NOT_UPLOAD: Data will not be uploaded, only references will be written
 * @export
 * @enum {string}
 */
export enum IOStrategyUploadMode {
  UPLOADONEXIT = <any>"UPLOAD_ON_EXIT",
  UPLOADEAGER = <any>"UPLOAD_EAGER",
  DONOTUPLOAD = <any>"DO_NOT_UPLOAD",
}

/**
 *  - FAIL: By default, if this plugin is not enabled for a Flyte deployment then execution will fail.  - USE_DEFAULT: Uses the system-configured default implementation.
 * @export
 * @enum {string}
 */
export enum PluginOverrideMissingPluginBehavior {
  FAIL = <any>"FAIL",
  USEDEFAULT = <any>"USE_DEFAULT",
}

/**
 * The state of the project is used to control its visibility in the UI and validity.   - ACTIVE: By default, all projects are considered active.  - ARCHIVED: Archived projects are no longer visible in the UI and no longer valid.  - SYSTEM_GENERATED: System generated projects that aren't explicitly created or managed by a user.
 * @export
 * @enum {string}
 */
export enum ProjectProjectState {
  ACTIVE = <any>"ACTIVE",
  ARCHIVED = <any>"ARCHIVED",
  SYSTEMGENERATED = <any>"SYSTEM_GENERATED",
}

/**
 * `ListValue` is a wrapper around a repeated field of values.  The JSON representation for `ListValue` is JSON array.
 * @export
 * @interface ProtobufListValue
 */
export interface ProtobufListValue {
  /**
   * Repeated field of dynamically typed values.
   * @type {Array<ProtobufValue>}
   * @memberof ProtobufListValue
   */
  values?: Array<ProtobufValue>;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
  NULLVALUE = <any>"NULL_VALUE",
}

/**
 * `Struct` represents a structured data value, consisting of fields which map to dynamically typed values. In some languages, `Struct` might be supported by a native representation. For example, in scripting languages like JS a struct is represented as an object. The details of that representation are described together with the proto support for the language.  The JSON representation for `Struct` is JSON object.
 * @export
 * @interface ProtobufStruct
 */
export interface ProtobufStruct {
  /**
   * Unordered map of dynamically typed values.
   * @type {{ [key: string]: ProtobufValue; }}
   * @memberof ProtobufStruct
   */
  fields?: { [key: string]: ProtobufValue };
}

/**
 * `Value` represents a dynamically typed value which can be either null, a number, a string, a boolean, a recursive struct value, or a list of values. A producer of value is expected to set one of that variants, absence of any variant indicates an error.  The JSON representation for `Value` is JSON value.
 * @export
 * @interface ProtobufValue
 */
export interface ProtobufValue {
  /**
   * Represents a null value.
   * @type {ProtobufNullValue}
   * @memberof ProtobufValue
   */
  nullValue?: ProtobufNullValue;
  /**
   * Represents a double value.
   * @type {number}
   * @memberof ProtobufValue
   */
  numberValue?: number;
  /**
   * Represents a string value.
   * @type {string}
   * @memberof ProtobufValue
   */
  stringValue?: string;
  /**
   * Represents a boolean value.
   * @type {boolean}
   * @memberof ProtobufValue
   */
  boolValue?: boolean;
  /**
   * Represents a structured value.
   * @type {ProtobufStruct}
   * @memberof ProtobufValue
   */
  structValue?: ProtobufStruct;
  /**
   * Represents a repeated `Value`.
   * @type {ProtobufListValue}
   * @memberof ProtobufValue
   */
  listValue?: ProtobufListValue;
}

/**
 *  - UNDEFINED: Default: no quality of service specified.
 * @export
 * @enum {string}
 */
export enum QualityOfServiceTier {
  UNDEFINED = <any>"UNDEFINED",
  HIGH = <any>"HIGH",
  MEDIUM = <any>"MEDIUM",
  LOW = <any>"LOW",
}

/**
 * Encapsulates a resource name and value.
 * @export
 * @interface ResourcesResourceEntry
 */
export interface ResourcesResourceEntry {
  /**
   * Resource name.
   * @type {ResourcesResourceName}
   * @memberof ResourcesResourceEntry
   */
  name?: ResourcesResourceName;
  /**
   *
   * @type {string}
   * @memberof ResourcesResourceEntry
   */
  value?: string;
}

/**
 * Known resource names.   - EPHEMERAL_STORAGE: For Kubernetes-based deployments, pods use ephemeral local storage for scratch space, caching, and for logs.
 * @export
 * @enum {string}
 */
export enum ResourcesResourceName {
  UNKNOWN = <any>"UNKNOWN",
  CPU = <any>"CPU",
  GPU = <any>"GPU",
  MEMORY = <any>"MEMORY",
  STORAGE = <any>"STORAGE",
  EPHEMERALSTORAGE = <any>"EPHEMERAL_STORAGE",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum RuntimeMetadataRuntimeType {
  OTHER = <any>"OTHER",
  FLYTESDK = <any>"FLYTE_SDK",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum SchemaColumnSchemaColumnType {
  INTEGER = <any>"INTEGER",
  FLOAT = <any>"FLOAT",
  STRING = <any>"STRING",
  BOOLEAN = <any>"BOOLEAN",
  DATETIME = <any>"DATETIME",
  DURATION = <any>"DURATION",
}

/**
 *
 * @export
 * @interface SchemaTypeSchemaColumn
 */
export interface SchemaTypeSchemaColumn {
  /**
   *
   * @type {string}
   * @memberof SchemaTypeSchemaColumn
   */
  name?: string;
  /**
   * The column type. This allows a limited set of types currently.
   * @type {SchemaColumnSchemaColumnType}
   * @memberof SchemaTypeSchemaColumn
   */
  type?: SchemaColumnSchemaColumnType;
}

/**
 *  - ANY: Default case, indicates the client can tolerate either mounting options.  - ENV_VAR: ENV_VAR indicates the secret needs to be mounted as an environment variable.  - FILE: FILE indicates the secret needs to be mounted as a file.
 * @export
 * @enum {string}
 */
export enum SecretMountType {
  ANY = <any>"ANY",
  ENVVAR = <any>"ENV_VAR",
  FILE = <any>"FILE",
}

/**
 *  - DESCENDING: By default, fields are sorted in descending order.
 * @export
 * @enum {string}
 */
export enum SortDirection {
  DESCENDING = <any>"DESCENDING",
  ASCENDING = <any>"ASCENDING",
}

/**
 * The dialect of the SQL statement. This is used to validate and parse SQL statements at compilation time to avoid expensive runtime operations. If set to an unsupported dialect, no validation will be done on the statement. We support the following dialect: ansi, hive.
 * @export
 * @enum {string}
 */
export enum SqlDialect {
  UNDEFINED = <any>"UNDEFINED",
  ANSI = <any>"ANSI",
  HIVE = <any>"HIVE",
  OTHER = <any>"OTHER",
}

/**
 *
 * @export
 * @interface StructuredDatasetTypeDatasetColumn
 */
export interface StructuredDatasetTypeDatasetColumn {
  /**
   * A unique name within the schema type for the column.
   * @type {string}
   * @memberof StructuredDatasetTypeDatasetColumn
   */
  name?: string;
  /**
   * The column type.
   * @type {CoreLiteralType}
   * @memberof StructuredDatasetTypeDatasetColumn
   */
  literalType?: CoreLiteralType;
}

/**
 * Includes the broad category of machine used for this specific task execution.   - DEFAULT: The default instance class configured for the flyte application platform.  - INTERRUPTIBLE: The instance class configured for interruptible tasks.
 * @export
 * @enum {string}
 */
export enum TaskExecutionMetadataInstanceClass {
  DEFAULT = <any>"DEFAULT",
  INTERRUPTIBLE = <any>"INTERRUPTIBLE",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum TaskLogMessageFormat {
  UNKNOWN = <any>"UNKNOWN",
  CSV = <any>"CSV",
  JSON = <any>"JSON",
}

/**
 * - FAIL_IMMEDIATELY: FAIL_IMMEDIATELY instructs the system to fail as soon as a node fails in the workflow. It'll automatically abort all currently running nodes and clean up resources before finally marking the workflow executions as failed.  - FAIL_AFTER_EXECUTABLE_NODES_COMPLETE: FAIL_AFTER_EXECUTABLE_NODES_COMPLETE instructs the system to make as much progress as it can. The system will not alter the dependencies of the execution graph so any node that depend on the failed node will not be run. Other nodes that will be executed to completion before cleaning up resources and marking the workflow execution as failed.
 * @export
 * @enum {string}
 */
export enum WorkflowMetadataOnFailurePolicy {
  IMMEDIATELY = <any>"FAIL_IMMEDIATELY",
  AFTEREXECUTABLENODESCOMPLETE = <any>"FAIL_AFTER_EXECUTABLE_NODES_COMPLETE",
}

/**
 * AdminServiceApi - fetch parameter creator
 * @export
 */
export const AdminServiceApiFetchParamCreator = function (
  _configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Triggers the creation of a :ref:`ref_flyteidl.admin.Execution`
     * @param {AdminExecutionCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExecution(
      body: AdminExecutionCreateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createExecution."
        );
      }
      const localVarPath = `/api/v1/executions`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminExecutionCreateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.LaunchPlan` definition
     * @param {AdminLaunchPlanCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLaunchPlan(
      body: AdminLaunchPlanCreateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createLaunchPlan."
        );
      }
      const localVarPath = `/api/v1/launch_plans`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminLaunchPlanCreateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.NodeExecutionEvent` has occurred.
     * @param {AdminNodeExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNodeEvent(
      body: AdminNodeExecutionEventRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createNodeEvent."
        );
      }
      const localVarPath = `/api/v1/events/nodes`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminNodeExecutionEventRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Task` definition
     * @param {FlyteidladminTaskCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTask(
      body: FlyteidladminTaskCreateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createTask."
        );
      }
      const localVarPath = `/api/v1/tasks`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"FlyteidladminTaskCreateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.TaskExecutionEvent` has occurred.
     * @param {AdminTaskExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskEvent(
      body: AdminTaskExecutionEventRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createTaskEvent."
        );
      }
      const localVarPath = `/api/v1/events/tasks`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminTaskExecutionEventRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Workflow` definition
     * @param {AdminWorkflowCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkflow(
      body: AdminWorkflowCreateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createWorkflow."
        );
      }
      const localVarPath = `/api/v1/workflows`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminWorkflowCreateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.WorkflowExecutionEvent` has occurred.
     * @param {AdminWorkflowExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkflowEvent(
      body: AdminWorkflowExecutionEventRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createWorkflowEvent."
        );
      }
      const localVarPath = `/api/v1/events/workflows`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminWorkflowExecutionEventRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {AdminProjectAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectAttributes(
      project: string,
      body: AdminProjectAttributesDeleteRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling deleteProjectAttributes."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling deleteProjectAttributes."
        );
      }
      const localVarPath = `/api/v1/project_attributes/{project}`.replace(
        `{${"project"}}`,
        encodeURIComponent(String(project))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminProjectAttributesDeleteRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {AdminProjectDomainAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectDomainAttributes(
      project: string,
      domain: string,
      body: AdminProjectDomainAttributesDeleteRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling deleteProjectDomainAttributes."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling deleteProjectDomainAttributes."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling deleteProjectDomainAttributes."
        );
      }
      const localVarPath =
        `/api/v1/project_domain_attributes/{project}/{domain}`
          .replace(`{${"project"}}`, encodeURIComponent(String(project)))
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminProjectDomainAttributesDeleteRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {string} workflow Workflow name which this set of attributes references. +required
     * @param {AdminWorkflowAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkflowAttributes(
      project: string,
      domain: string,
      workflow: string,
      body: AdminWorkflowAttributesDeleteRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling deleteWorkflowAttributes."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling deleteWorkflowAttributes."
        );
      }
      // verify required parameter 'workflow' is not null or undefined
      if (workflow === null || workflow === undefined) {
        throw new RequiredError(
          "workflow",
          "Required parameter workflow was null or undefined when calling deleteWorkflowAttributes."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling deleteWorkflowAttributes."
        );
      }
      const localVarPath =
        `/api/v1/workflow_attributes/{project}/{domain}/{workflow}`
          .replace(`{${"project"}}`, encodeURIComponent(String(project)))
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
          .replace(`{${"workflow"}}`, encodeURIComponent(String(workflow)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminWorkflowAttributesDeleteRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch the active version of a :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getActiveLaunchPlan."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getActiveLaunchPlan."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getActiveLaunchPlan."
        );
      }
      const localVarPath =
        `/api/v1/active_launch_plans/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.DescriptionEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} idResourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDescriptionEntity(
      idResourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idResourceType' is not null or undefined
      if (idResourceType === null || idResourceType === undefined) {
        throw new RequiredError(
          "idResourceType",
          "Required parameter idResourceType was null or undefined when calling getDescriptionEntity."
        );
      }
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getDescriptionEntity."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getDescriptionEntity."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getDescriptionEntity."
        );
      }
      // verify required parameter 'idVersion' is not null or undefined
      if (idVersion === null || idVersion === undefined) {
        throw new RequiredError(
          "idVersion",
          "Required parameter idVersion was null or undefined when calling getDescriptionEntity."
        );
      }
      const localVarPath =
        `/api/v1/description_entities/{id.resource_type}/{id.project}/{id.domain}/{id.name}/{id.version}`
          .replace(
            `{${"id.resource_type"}}`,
            encodeURIComponent(String(idResourceType))
          )
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)))
          .replace(`{${"id.version"}}`, encodeURIComponent(String(idVersion)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getExecution."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getExecution."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getExecution."
        );
      }
      const localVarPath =
        `/api/v1/executions/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutionData(
      idProject: string,
      idDomain: string,
      idName: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getExecutionData."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getExecutionData."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getExecutionData."
        );
      }
      const localVarPath =
        `/api/v1/data/executions/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches runtime metrics for a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {number} [depth] depth defines the number of Flyte entity levels to traverse when breaking down execution details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutionMetrics(
      idProject: string,
      idDomain: string,
      idName: string,
      depth?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getExecutionMetrics."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getExecutionMetrics."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getExecutionMetrics."
        );
      }
      const localVarPath =
        `/api/v1/metrics/executions/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.LaunchPlan` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getLaunchPlan."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getLaunchPlan."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getLaunchPlan."
        );
      }
      // verify required parameter 'idVersion' is not null or undefined
      if (idVersion === null || idVersion === undefined) {
        throw new RequiredError(
          "idVersion",
          "Required parameter idVersion was null or undefined when calling getLaunchPlan."
        );
      }
      const localVarPath =
        `/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}/{id.version}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)))
          .replace(`{${"id.version"}}`, encodeURIComponent(String(idVersion)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idResourceType !== undefined) {
        localVarQueryParameter["id.resource_type"] = idResourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to get. One of Task, Workflow or LaunchPlan. +required
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNamedEntity(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'resourceType' is not null or undefined
      if (resourceType === null || resourceType === undefined) {
        throw new RequiredError(
          "resourceType",
          "Required parameter resourceType was null or undefined when calling getNamedEntity."
        );
      }
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getNamedEntity."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getNamedEntity."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getNamedEntity."
        );
      }
      const localVarPath =
        `/api/v1/named_entities/{resource_type}/{id.project}/{id.domain}/{id.name}`
          .replace(
            `{${"resource_type"}}`,
            encodeURIComponent(String(resourceType))
          )
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} idExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeExecution(
      idExecutionIdProject: string,
      idExecutionIdDomain: string,
      idExecutionIdName: string,
      idNodeId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idExecutionIdProject' is not null or undefined
      if (idExecutionIdProject === null || idExecutionIdProject === undefined) {
        throw new RequiredError(
          "idExecutionIdProject",
          "Required parameter idExecutionIdProject was null or undefined when calling getNodeExecution."
        );
      }
      // verify required parameter 'idExecutionIdDomain' is not null or undefined
      if (idExecutionIdDomain === null || idExecutionIdDomain === undefined) {
        throw new RequiredError(
          "idExecutionIdDomain",
          "Required parameter idExecutionIdDomain was null or undefined when calling getNodeExecution."
        );
      }
      // verify required parameter 'idExecutionIdName' is not null or undefined
      if (idExecutionIdName === null || idExecutionIdName === undefined) {
        throw new RequiredError(
          "idExecutionIdName",
          "Required parameter idExecutionIdName was null or undefined when calling getNodeExecution."
        );
      }
      // verify required parameter 'idNodeId' is not null or undefined
      if (idNodeId === null || idNodeId === undefined) {
        throw new RequiredError(
          "idNodeId",
          "Required parameter idNodeId was null or undefined when calling getNodeExecution."
        );
      }
      const localVarPath =
        `/api/v1/node_executions/{id.execution_id.project}/{id.execution_id.domain}/{id.execution_id.name}/{id.node_id}`
          .replace(
            `{${"id.execution_id.project"}}`,
            encodeURIComponent(String(idExecutionIdProject))
          )
          .replace(
            `{${"id.execution_id.domain"}}`,
            encodeURIComponent(String(idExecutionIdDomain))
          )
          .replace(
            `{${"id.execution_id.name"}}`,
            encodeURIComponent(String(idExecutionIdName))
          )
          .replace(`{${"id.node_id"}}`, encodeURIComponent(String(idNodeId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} idExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeExecutionData(
      idExecutionIdProject: string,
      idExecutionIdDomain: string,
      idExecutionIdName: string,
      idNodeId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idExecutionIdProject' is not null or undefined
      if (idExecutionIdProject === null || idExecutionIdProject === undefined) {
        throw new RequiredError(
          "idExecutionIdProject",
          "Required parameter idExecutionIdProject was null or undefined when calling getNodeExecutionData."
        );
      }
      // verify required parameter 'idExecutionIdDomain' is not null or undefined
      if (idExecutionIdDomain === null || idExecutionIdDomain === undefined) {
        throw new RequiredError(
          "idExecutionIdDomain",
          "Required parameter idExecutionIdDomain was null or undefined when calling getNodeExecutionData."
        );
      }
      // verify required parameter 'idExecutionIdName' is not null or undefined
      if (idExecutionIdName === null || idExecutionIdName === undefined) {
        throw new RequiredError(
          "idExecutionIdName",
          "Required parameter idExecutionIdName was null or undefined when calling getNodeExecutionData."
        );
      }
      // verify required parameter 'idNodeId' is not null or undefined
      if (idNodeId === null || idNodeId === undefined) {
        throw new RequiredError(
          "idNodeId",
          "Required parameter idNodeId was null or undefined when calling getNodeExecutionData."
        );
      }
      const localVarPath =
        `/api/v1/data/node_executions/{id.execution_id.project}/{id.execution_id.domain}/{id.execution_id.name}/{id.node_id}`
          .replace(
            `{${"id.execution_id.project"}}`,
            encodeURIComponent(String(idExecutionIdProject))
          )
          .replace(
            `{${"id.execution_id.domain"}}`,
            encodeURIComponent(String(idExecutionIdDomain))
          )
          .replace(
            `{${"id.execution_id.name"}}`,
            encodeURIComponent(String(idExecutionIdName))
          )
          .replace(`{${"id.node_id"}}`, encodeURIComponent(String(idNodeId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectAttributes(
      project: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling getProjectAttributes."
        );
      }
      const localVarPath = `/api/v1/project_attributes/{project}`.replace(
        `{${"project"}}`,
        encodeURIComponent(String(project))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (resourceType !== undefined) {
        localVarQueryParameter["resource_type"] = resourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDomainAttributes(
      project: string,
      domain: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling getProjectDomainAttributes."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling getProjectDomainAttributes."
        );
      }
      const localVarPath =
        `/api/v1/project_domain_attributes/{project}/{domain}`
          .replace(`{${"project"}}`, encodeURIComponent(String(project)))
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (resourceType !== undefined) {
        localVarQueryParameter["resource_type"] = resourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.Task` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getTask."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getTask."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getTask."
        );
      }
      // verify required parameter 'idVersion' is not null or undefined
      if (idVersion === null || idVersion === undefined) {
        throw new RequiredError(
          "idVersion",
          "Required parameter idVersion was null or undefined when calling getTask."
        );
      }
      const localVarPath =
        `/api/v1/tasks/{id.project}/{id.domain}/{id.name}/{id.version}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)))
          .replace(`{${"id.version"}}`, encodeURIComponent(String(idVersion)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idResourceType !== undefined) {
        localVarQueryParameter["id.resource_type"] = idResourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeExecutionIdNodeId
     * @param {string} idTaskIdProject Name of the project the resource belongs to.
     * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idTaskIdName User provided value for the resource.
     * @param {string} idTaskIdVersion Specific version of the resource.
     * @param {number} idRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskExecution(
      idNodeExecutionIdExecutionIdProject: string,
      idNodeExecutionIdExecutionIdDomain: string,
      idNodeExecutionIdExecutionIdName: string,
      idNodeExecutionIdNodeId: string,
      idTaskIdProject: string,
      idTaskIdDomain: string,
      idTaskIdName: string,
      idTaskIdVersion: string,
      idRetryAttempt: number,
      idTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idNodeExecutionIdExecutionIdProject' is not null or undefined
      if (
        idNodeExecutionIdExecutionIdProject === null ||
        idNodeExecutionIdExecutionIdProject === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdExecutionIdProject",
          "Required parameter idNodeExecutionIdExecutionIdProject was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idNodeExecutionIdExecutionIdDomain' is not null or undefined
      if (
        idNodeExecutionIdExecutionIdDomain === null ||
        idNodeExecutionIdExecutionIdDomain === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdExecutionIdDomain",
          "Required parameter idNodeExecutionIdExecutionIdDomain was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idNodeExecutionIdExecutionIdName' is not null or undefined
      if (
        idNodeExecutionIdExecutionIdName === null ||
        idNodeExecutionIdExecutionIdName === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdExecutionIdName",
          "Required parameter idNodeExecutionIdExecutionIdName was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idNodeExecutionIdNodeId' is not null or undefined
      if (
        idNodeExecutionIdNodeId === null ||
        idNodeExecutionIdNodeId === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdNodeId",
          "Required parameter idNodeExecutionIdNodeId was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idTaskIdProject' is not null or undefined
      if (idTaskIdProject === null || idTaskIdProject === undefined) {
        throw new RequiredError(
          "idTaskIdProject",
          "Required parameter idTaskIdProject was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idTaskIdDomain' is not null or undefined
      if (idTaskIdDomain === null || idTaskIdDomain === undefined) {
        throw new RequiredError(
          "idTaskIdDomain",
          "Required parameter idTaskIdDomain was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idTaskIdName' is not null or undefined
      if (idTaskIdName === null || idTaskIdName === undefined) {
        throw new RequiredError(
          "idTaskIdName",
          "Required parameter idTaskIdName was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idTaskIdVersion' is not null or undefined
      if (idTaskIdVersion === null || idTaskIdVersion === undefined) {
        throw new RequiredError(
          "idTaskIdVersion",
          "Required parameter idTaskIdVersion was null or undefined when calling getTaskExecution."
        );
      }
      // verify required parameter 'idRetryAttempt' is not null or undefined
      if (idRetryAttempt === null || idRetryAttempt === undefined) {
        throw new RequiredError(
          "idRetryAttempt",
          "Required parameter idRetryAttempt was null or undefined when calling getTaskExecution."
        );
      }
      const localVarPath =
        `/api/v1/task_executions/{id.node_execution_id.execution_id.project}/{id.node_execution_id.execution_id.domain}/{id.node_execution_id.execution_id.name}/{id.node_execution_id.node_id}/{id.task_id.project}/{id.task_id.domain}/{id.task_id.name}/{id.task_id.version}/{id.retry_attempt}`
          .replace(
            `{${"id.node_execution_id.execution_id.project"}}`,
            encodeURIComponent(String(idNodeExecutionIdExecutionIdProject))
          )
          .replace(
            `{${"id.node_execution_id.execution_id.domain"}}`,
            encodeURIComponent(String(idNodeExecutionIdExecutionIdDomain))
          )
          .replace(
            `{${"id.node_execution_id.execution_id.name"}}`,
            encodeURIComponent(String(idNodeExecutionIdExecutionIdName))
          )
          .replace(
            `{${"id.node_execution_id.node_id"}}`,
            encodeURIComponent(String(idNodeExecutionIdNodeId))
          )
          .replace(
            `{${"id.task_id.project"}}`,
            encodeURIComponent(String(idTaskIdProject))
          )
          .replace(
            `{${"id.task_id.domain"}}`,
            encodeURIComponent(String(idTaskIdDomain))
          )
          .replace(
            `{${"id.task_id.name"}}`,
            encodeURIComponent(String(idTaskIdName))
          )
          .replace(
            `{${"id.task_id.version"}}`,
            encodeURIComponent(String(idTaskIdVersion))
          )
          .replace(
            `{${"id.retry_attempt"}}`,
            encodeURIComponent(String(idRetryAttempt))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idTaskIdResourceType !== undefined) {
        localVarQueryParameter["id.task_id.resource_type"] =
          idTaskIdResourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeExecutionIdNodeId
     * @param {string} idTaskIdProject Name of the project the resource belongs to.
     * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idTaskIdName User provided value for the resource.
     * @param {string} idTaskIdVersion Specific version of the resource.
     * @param {number} idRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskExecutionData(
      idNodeExecutionIdExecutionIdProject: string,
      idNodeExecutionIdExecutionIdDomain: string,
      idNodeExecutionIdExecutionIdName: string,
      idNodeExecutionIdNodeId: string,
      idTaskIdProject: string,
      idTaskIdDomain: string,
      idTaskIdName: string,
      idTaskIdVersion: string,
      idRetryAttempt: number,
      idTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idNodeExecutionIdExecutionIdProject' is not null or undefined
      if (
        idNodeExecutionIdExecutionIdProject === null ||
        idNodeExecutionIdExecutionIdProject === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdExecutionIdProject",
          "Required parameter idNodeExecutionIdExecutionIdProject was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idNodeExecutionIdExecutionIdDomain' is not null or undefined
      if (
        idNodeExecutionIdExecutionIdDomain === null ||
        idNodeExecutionIdExecutionIdDomain === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdExecutionIdDomain",
          "Required parameter idNodeExecutionIdExecutionIdDomain was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idNodeExecutionIdExecutionIdName' is not null or undefined
      if (
        idNodeExecutionIdExecutionIdName === null ||
        idNodeExecutionIdExecutionIdName === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdExecutionIdName",
          "Required parameter idNodeExecutionIdExecutionIdName was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idNodeExecutionIdNodeId' is not null or undefined
      if (
        idNodeExecutionIdNodeId === null ||
        idNodeExecutionIdNodeId === undefined
      ) {
        throw new RequiredError(
          "idNodeExecutionIdNodeId",
          "Required parameter idNodeExecutionIdNodeId was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idTaskIdProject' is not null or undefined
      if (idTaskIdProject === null || idTaskIdProject === undefined) {
        throw new RequiredError(
          "idTaskIdProject",
          "Required parameter idTaskIdProject was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idTaskIdDomain' is not null or undefined
      if (idTaskIdDomain === null || idTaskIdDomain === undefined) {
        throw new RequiredError(
          "idTaskIdDomain",
          "Required parameter idTaskIdDomain was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idTaskIdName' is not null or undefined
      if (idTaskIdName === null || idTaskIdName === undefined) {
        throw new RequiredError(
          "idTaskIdName",
          "Required parameter idTaskIdName was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idTaskIdVersion' is not null or undefined
      if (idTaskIdVersion === null || idTaskIdVersion === undefined) {
        throw new RequiredError(
          "idTaskIdVersion",
          "Required parameter idTaskIdVersion was null or undefined when calling getTaskExecutionData."
        );
      }
      // verify required parameter 'idRetryAttempt' is not null or undefined
      if (idRetryAttempt === null || idRetryAttempt === undefined) {
        throw new RequiredError(
          "idRetryAttempt",
          "Required parameter idRetryAttempt was null or undefined when calling getTaskExecutionData."
        );
      }
      const localVarPath =
        `/api/v1/data/task_executions/{id.node_execution_id.execution_id.project}/{id.node_execution_id.execution_id.domain}/{id.node_execution_id.execution_id.name}/{id.node_execution_id.node_id}/{id.task_id.project}/{id.task_id.domain}/{id.task_id.name}/{id.task_id.version}/{id.retry_attempt}`
          .replace(
            `{${"id.node_execution_id.execution_id.project"}}`,
            encodeURIComponent(String(idNodeExecutionIdExecutionIdProject))
          )
          .replace(
            `{${"id.node_execution_id.execution_id.domain"}}`,
            encodeURIComponent(String(idNodeExecutionIdExecutionIdDomain))
          )
          .replace(
            `{${"id.node_execution_id.execution_id.name"}}`,
            encodeURIComponent(String(idNodeExecutionIdExecutionIdName))
          )
          .replace(
            `{${"id.node_execution_id.node_id"}}`,
            encodeURIComponent(String(idNodeExecutionIdNodeId))
          )
          .replace(
            `{${"id.task_id.project"}}`,
            encodeURIComponent(String(idTaskIdProject))
          )
          .replace(
            `{${"id.task_id.domain"}}`,
            encodeURIComponent(String(idTaskIdDomain))
          )
          .replace(
            `{${"id.task_id.name"}}`,
            encodeURIComponent(String(idTaskIdName))
          )
          .replace(
            `{${"id.task_id.version"}}`,
            encodeURIComponent(String(idTaskIdVersion))
          )
          .replace(
            `{${"id.retry_attempt"}}`,
            encodeURIComponent(String(idRetryAttempt))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idTaskIdResourceType !== undefined) {
        localVarQueryParameter["id.task_id.resource_type"] =
          idTaskIdResourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options: any = {}): FetchArgs {
      const localVarPath = `/api/v1/version`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.Workflow` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflow(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling getWorkflow."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling getWorkflow."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling getWorkflow."
        );
      }
      // verify required parameter 'idVersion' is not null or undefined
      if (idVersion === null || idVersion === undefined) {
        throw new RequiredError(
          "idVersion",
          "Required parameter idVersion was null or undefined when calling getWorkflow."
        );
      }
      const localVarPath =
        `/api/v1/workflows/{id.project}/{id.domain}/{id.name}/{id.version}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)))
          .replace(`{${"id.version"}}`, encodeURIComponent(String(idVersion)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idResourceType !== undefined) {
        localVarQueryParameter["id.resource_type"] = idResourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {string} workflow Workflow name which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflowAttributes(
      project: string,
      domain: string,
      workflow: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling getWorkflowAttributes."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling getWorkflowAttributes."
        );
      }
      // verify required parameter 'workflow' is not null or undefined
      if (workflow === null || workflow === undefined) {
        throw new RequiredError(
          "workflow",
          "Required parameter workflow was null or undefined when calling getWorkflowAttributes."
        );
      }
      const localVarPath =
        `/api/v1/workflow_attributes/{project}/{domain}/{workflow}`
          .replace(`{${"project"}}`, encodeURIComponent(String(project)))
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
          .replace(`{${"workflow"}}`, encodeURIComponent(String(workflow)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (resourceType !== undefined) {
        localVarQueryParameter["resource_type"] = resourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List active versions of :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} project Name of the project that contains the identifiers. +required.
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listActiveLaunchPlans(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling listActiveLaunchPlans."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling listActiveLaunchPlans."
        );
      }
      const localVarPath = `/api/v1/active_launch_plans/{project}/{domain}`
        .replace(`{${"project"}}`, encodeURIComponent(String(project)))
        .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDescriptionEntities(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'resourceType' is not null or undefined
      if (resourceType === null || resourceType === undefined) {
        throw new RequiredError(
          "resourceType",
          "Required parameter resourceType was null or undefined when calling listDescriptionEntities."
        );
      }
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listDescriptionEntities."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listDescriptionEntities."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling listDescriptionEntities."
        );
      }
      const localVarPath =
        `/api/v1/description_entities/{resource_type}/{id.project}/{id.domain}/{id.name}`
          .replace(
            `{${"resource_type"}}`,
            encodeURIComponent(String(resourceType))
          )
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDescriptionEntities2(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'resourceType' is not null or undefined
      if (resourceType === null || resourceType === undefined) {
        throw new RequiredError(
          "resourceType",
          "Required parameter resourceType was null or undefined when calling listDescriptionEntities2."
        );
      }
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listDescriptionEntities2."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listDescriptionEntities2."
        );
      }
      const localVarPath =
        `/api/v1/description_entities/{resource_type}/{id.project}/{id.domain}`
          .replace(
            `{${"resource_type"}}`,
            encodeURIComponent(String(resourceType))
          )
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idName !== undefined) {
        localVarQueryParameter["id.name"] = idName;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExecutions(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listExecutions."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listExecutions."
        );
      }
      const localVarPath = `/api/v1/executions/{id.project}/{id.domain}`
        .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
        .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idName !== undefined) {
        localVarQueryParameter["id.name"] = idName;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of launch plan objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlanIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling listLaunchPlanIds."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling listLaunchPlanIds."
        );
      }
      const localVarPath = `/api/v1/launch_plan_ids/{project}/{domain}`
        .replace(`{${"project"}}`, encodeURIComponent(String(project)))
        .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlans(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listLaunchPlans."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listLaunchPlans."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling listLaunchPlans."
        );
      }
      const localVarPath =
        `/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlans2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listLaunchPlans2."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listLaunchPlans2."
        );
      }
      const localVarPath = `/api/v1/launch_plans/{id.project}/{id.domain}`
        .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
        .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idName !== undefined) {
        localVarQueryParameter["id.name"] = idName;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Lists custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a specific resource type.
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMatchableAttributes(
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/v1/matchable_attributes`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (resourceType !== undefined) {
        localVarQueryParameter["resource_type"] = resourceType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns a list of :ref:`ref_flyteidl.admin.NamedEntity` objects.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to query. One of Task, Workflow or LaunchPlan. +required
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project.
     * @param {number} [limit] Indicates the number of resources to be returned.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNamedEntities(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'resourceType' is not null or undefined
      if (resourceType === null || resourceType === undefined) {
        throw new RequiredError(
          "resourceType",
          "Required parameter resourceType was null or undefined when calling listNamedEntities."
        );
      }
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling listNamedEntities."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling listNamedEntities."
        );
      }
      const localVarPath =
        `/api/v1/named_entities/{resource_type}/{project}/{domain}`
          .replace(
            `{${"resource_type"}}`,
            encodeURIComponent(String(resourceType))
          )
          .replace(`{${"project"}}`, encodeURIComponent(String(project)))
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} workflowExecutionIdProject Name of the project the resource belongs to.
     * @param {string} workflowExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} workflowExecutionIdName User or system provided value for the resource.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token]
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [uniqueParentId] Unique identifier of the parent node in the execution +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeExecutions(
      workflowExecutionIdProject: string,
      workflowExecutionIdDomain: string,
      workflowExecutionIdName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      uniqueParentId?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'workflowExecutionIdProject' is not null or undefined
      if (
        workflowExecutionIdProject === null ||
        workflowExecutionIdProject === undefined
      ) {
        throw new RequiredError(
          "workflowExecutionIdProject",
          "Required parameter workflowExecutionIdProject was null or undefined when calling listNodeExecutions."
        );
      }
      // verify required parameter 'workflowExecutionIdDomain' is not null or undefined
      if (
        workflowExecutionIdDomain === null ||
        workflowExecutionIdDomain === undefined
      ) {
        throw new RequiredError(
          "workflowExecutionIdDomain",
          "Required parameter workflowExecutionIdDomain was null or undefined when calling listNodeExecutions."
        );
      }
      // verify required parameter 'workflowExecutionIdName' is not null or undefined
      if (
        workflowExecutionIdName === null ||
        workflowExecutionIdName === undefined
      ) {
        throw new RequiredError(
          "workflowExecutionIdName",
          "Required parameter workflowExecutionIdName was null or undefined when calling listNodeExecutions."
        );
      }
      const localVarPath =
        `/api/v1/node_executions/{workflow_execution_id.project}/{workflow_execution_id.domain}/{workflow_execution_id.name}`
          .replace(
            `{${"workflow_execution_id.project"}}`,
            encodeURIComponent(String(workflowExecutionIdProject))
          )
          .replace(
            `{${"workflow_execution_id.domain"}}`,
            encodeURIComponent(String(workflowExecutionIdDomain))
          )
          .replace(
            `{${"workflow_execution_id.name"}}`,
            encodeURIComponent(String(workflowExecutionIdName))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      if (uniqueParentId !== undefined) {
        localVarQueryParameter["unique_parent_id"] = uniqueParentId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution` launched by the reference :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} taskExecutionIdNodeExecutionIdNodeId
     * @param {string} taskExecutionIdTaskIdProject Name of the project the resource belongs to.
     * @param {string} taskExecutionIdTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} taskExecutionIdTaskIdName User provided value for the resource.
     * @param {string} taskExecutionIdTaskIdVersion Specific version of the resource.
     * @param {number} taskExecutionIdRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [taskExecutionIdTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the, server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeExecutionsForTask(
      taskExecutionIdNodeExecutionIdExecutionIdProject: string,
      taskExecutionIdNodeExecutionIdExecutionIdDomain: string,
      taskExecutionIdNodeExecutionIdExecutionIdName: string,
      taskExecutionIdNodeExecutionIdNodeId: string,
      taskExecutionIdTaskIdProject: string,
      taskExecutionIdTaskIdDomain: string,
      taskExecutionIdTaskIdName: string,
      taskExecutionIdTaskIdVersion: string,
      taskExecutionIdRetryAttempt: number,
      taskExecutionIdTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'taskExecutionIdNodeExecutionIdExecutionIdProject' is not null or undefined
      if (
        taskExecutionIdNodeExecutionIdExecutionIdProject === null ||
        taskExecutionIdNodeExecutionIdExecutionIdProject === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdNodeExecutionIdExecutionIdProject",
          "Required parameter taskExecutionIdNodeExecutionIdExecutionIdProject was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdNodeExecutionIdExecutionIdDomain' is not null or undefined
      if (
        taskExecutionIdNodeExecutionIdExecutionIdDomain === null ||
        taskExecutionIdNodeExecutionIdExecutionIdDomain === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdNodeExecutionIdExecutionIdDomain",
          "Required parameter taskExecutionIdNodeExecutionIdExecutionIdDomain was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdNodeExecutionIdExecutionIdName' is not null or undefined
      if (
        taskExecutionIdNodeExecutionIdExecutionIdName === null ||
        taskExecutionIdNodeExecutionIdExecutionIdName === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdNodeExecutionIdExecutionIdName",
          "Required parameter taskExecutionIdNodeExecutionIdExecutionIdName was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdNodeExecutionIdNodeId' is not null or undefined
      if (
        taskExecutionIdNodeExecutionIdNodeId === null ||
        taskExecutionIdNodeExecutionIdNodeId === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdNodeExecutionIdNodeId",
          "Required parameter taskExecutionIdNodeExecutionIdNodeId was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdTaskIdProject' is not null or undefined
      if (
        taskExecutionIdTaskIdProject === null ||
        taskExecutionIdTaskIdProject === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdTaskIdProject",
          "Required parameter taskExecutionIdTaskIdProject was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdTaskIdDomain' is not null or undefined
      if (
        taskExecutionIdTaskIdDomain === null ||
        taskExecutionIdTaskIdDomain === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdTaskIdDomain",
          "Required parameter taskExecutionIdTaskIdDomain was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdTaskIdName' is not null or undefined
      if (
        taskExecutionIdTaskIdName === null ||
        taskExecutionIdTaskIdName === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdTaskIdName",
          "Required parameter taskExecutionIdTaskIdName was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdTaskIdVersion' is not null or undefined
      if (
        taskExecutionIdTaskIdVersion === null ||
        taskExecutionIdTaskIdVersion === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdTaskIdVersion",
          "Required parameter taskExecutionIdTaskIdVersion was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      // verify required parameter 'taskExecutionIdRetryAttempt' is not null or undefined
      if (
        taskExecutionIdRetryAttempt === null ||
        taskExecutionIdRetryAttempt === undefined
      ) {
        throw new RequiredError(
          "taskExecutionIdRetryAttempt",
          "Required parameter taskExecutionIdRetryAttempt was null or undefined when calling listNodeExecutionsForTask."
        );
      }
      const localVarPath =
        `/api/v1/children/task_executions/{task_execution_id.node_execution_id.execution_id.project}/{task_execution_id.node_execution_id.execution_id.domain}/{task_execution_id.node_execution_id.execution_id.name}/{task_execution_id.node_execution_id.node_id}/{task_execution_id.task_id.project}/{task_execution_id.task_id.domain}/{task_execution_id.task_id.name}/{task_execution_id.task_id.version}/{task_execution_id.retry_attempt}`
          .replace(
            `{${"task_execution_id.node_execution_id.execution_id.project"}}`,
            encodeURIComponent(
              String(taskExecutionIdNodeExecutionIdExecutionIdProject)
            )
          )
          .replace(
            `{${"task_execution_id.node_execution_id.execution_id.domain"}}`,
            encodeURIComponent(
              String(taskExecutionIdNodeExecutionIdExecutionIdDomain)
            )
          )
          .replace(
            `{${"task_execution_id.node_execution_id.execution_id.name"}}`,
            encodeURIComponent(
              String(taskExecutionIdNodeExecutionIdExecutionIdName)
            )
          )
          .replace(
            `{${"task_execution_id.node_execution_id.node_id"}}`,
            encodeURIComponent(String(taskExecutionIdNodeExecutionIdNodeId))
          )
          .replace(
            `{${"task_execution_id.task_id.project"}}`,
            encodeURIComponent(String(taskExecutionIdTaskIdProject))
          )
          .replace(
            `{${"task_execution_id.task_id.domain"}}`,
            encodeURIComponent(String(taskExecutionIdTaskIdDomain))
          )
          .replace(
            `{${"task_execution_id.task_id.name"}}`,
            encodeURIComponent(String(taskExecutionIdTaskIdName))
          )
          .replace(
            `{${"task_execution_id.task_id.version"}}`,
            encodeURIComponent(String(taskExecutionIdTaskIdVersion))
          )
          .replace(
            `{${"task_execution_id.retry_attempt"}}`,
            encodeURIComponent(String(taskExecutionIdRetryAttempt))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (taskExecutionIdTaskIdResourceType !== undefined) {
        localVarQueryParameter["task_execution_id.task_id.resource_type"] =
          taskExecutionIdTaskIdResourceType;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.Project`
     * @param {number} [limit] Indicates the number of projects to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects(
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/v1/projects`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} nodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} nodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} nodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} nodeExecutionIdNodeId
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskExecutions(
      nodeExecutionIdExecutionIdProject: string,
      nodeExecutionIdExecutionIdDomain: string,
      nodeExecutionIdExecutionIdName: string,
      nodeExecutionIdNodeId: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'nodeExecutionIdExecutionIdProject' is not null or undefined
      if (
        nodeExecutionIdExecutionIdProject === null ||
        nodeExecutionIdExecutionIdProject === undefined
      ) {
        throw new RequiredError(
          "nodeExecutionIdExecutionIdProject",
          "Required parameter nodeExecutionIdExecutionIdProject was null or undefined when calling listTaskExecutions."
        );
      }
      // verify required parameter 'nodeExecutionIdExecutionIdDomain' is not null or undefined
      if (
        nodeExecutionIdExecutionIdDomain === null ||
        nodeExecutionIdExecutionIdDomain === undefined
      ) {
        throw new RequiredError(
          "nodeExecutionIdExecutionIdDomain",
          "Required parameter nodeExecutionIdExecutionIdDomain was null or undefined when calling listTaskExecutions."
        );
      }
      // verify required parameter 'nodeExecutionIdExecutionIdName' is not null or undefined
      if (
        nodeExecutionIdExecutionIdName === null ||
        nodeExecutionIdExecutionIdName === undefined
      ) {
        throw new RequiredError(
          "nodeExecutionIdExecutionIdName",
          "Required parameter nodeExecutionIdExecutionIdName was null or undefined when calling listTaskExecutions."
        );
      }
      // verify required parameter 'nodeExecutionIdNodeId' is not null or undefined
      if (
        nodeExecutionIdNodeId === null ||
        nodeExecutionIdNodeId === undefined
      ) {
        throw new RequiredError(
          "nodeExecutionIdNodeId",
          "Required parameter nodeExecutionIdNodeId was null or undefined when calling listTaskExecutions."
        );
      }
      const localVarPath =
        `/api/v1/task_executions/{node_execution_id.execution_id.project}/{node_execution_id.execution_id.domain}/{node_execution_id.execution_id.name}/{node_execution_id.node_id}`
          .replace(
            `{${"node_execution_id.execution_id.project"}}`,
            encodeURIComponent(String(nodeExecutionIdExecutionIdProject))
          )
          .replace(
            `{${"node_execution_id.execution_id.domain"}}`,
            encodeURIComponent(String(nodeExecutionIdExecutionIdDomain))
          )
          .replace(
            `{${"node_execution_id.execution_id.name"}}`,
            encodeURIComponent(String(nodeExecutionIdExecutionIdName))
          )
          .replace(
            `{${"node_execution_id.node_id"}}`,
            encodeURIComponent(String(nodeExecutionIdNodeId))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of task objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling listTaskIds."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling listTaskIds."
        );
      }
      const localVarPath = `/api/v1/task_ids/{project}/{domain}`
        .replace(`{${"project"}}`, encodeURIComponent(String(project)))
        .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTasks(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listTasks."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listTasks."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling listTasks."
        );
      }
      const localVarPath = `/api/v1/tasks/{id.project}/{id.domain}/{id.name}`
        .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
        .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
        .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTasks2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listTasks2."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listTasks2."
        );
      }
      const localVarPath = `/api/v1/tasks/{id.project}/{id.domain}`
        .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
        .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idName !== undefined) {
        localVarQueryParameter["id.name"] = idName;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of workflow objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflowIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'project' is not null or undefined
      if (project === null || project === undefined) {
        throw new RequiredError(
          "project",
          "Required parameter project was null or undefined when calling listWorkflowIds."
        );
      }
      // verify required parameter 'domain' is not null or undefined
      if (domain === null || domain === undefined) {
        throw new RequiredError(
          "domain",
          "Required parameter domain was null or undefined when calling listWorkflowIds."
        );
      }
      const localVarPath = `/api/v1/workflow_ids/{project}/{domain}`
        .replace(`{${"project"}}`, encodeURIComponent(String(project)))
        .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflows(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listWorkflows."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listWorkflows."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling listWorkflows."
        );
      }
      const localVarPath =
        `/api/v1/workflows/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflows2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling listWorkflows2."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling listWorkflows2."
        );
      }
      const localVarPath = `/api/v1/workflows/{id.project}/{id.domain}`
        .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
        .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idName !== undefined) {
        localVarQueryParameter["id.name"] = idName;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (sortByKey !== undefined) {
        localVarQueryParameter["sort_by.key"] = sortByKey;
      }

      if (sortByDirection !== undefined) {
        localVarQueryParameter["sort_by.direction"] = sortByDirection;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Recreates a previously-run workflow execution that will only start executing from the last known failure point. In Recover mode, users cannot change any input parameters or update the version of the execution. This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures, downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again. See :ref:`ref_flyteidl.admin.ExecutionRecoverRequest` for more details.
     * @param {AdminExecutionRecoverRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recoverExecution(
      body: AdminExecutionRecoverRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling recoverExecution."
        );
      }
      const localVarPath = `/api/v1/executions/recover`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminExecutionRecoverRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers a :ref:`ref_flyteidl.admin.Project` with the Flyte deployment.
     * @param {AdminProjectRegisterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerProject(
      body: AdminProjectRegisterRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling registerProject."
        );
      }
      const localVarPath = `/api/v1/projects`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminProjectRegisterRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Triggers the creation of an identical :ref:`ref_flyteidl.admin.Execution`
     * @param {AdminExecutionRelaunchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relaunchExecution(
      body: AdminExecutionRelaunchRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling relaunchExecution."
        );
      }
      const localVarPath = `/api/v1/executions/relaunch`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminExecutionRelaunchRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Terminates an in-progress :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {AdminExecutionTerminateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminExecutionTerminateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling terminateExecution."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling terminateExecution."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling terminateExecution."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling terminateExecution."
        );
      }
      const localVarPath =
        `/api/v1/executions/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminExecutionTerminateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update execution belonging to project domain :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {AdminExecutionUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminExecutionUpdateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling updateExecution."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling updateExecution."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling updateExecution."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateExecution."
        );
      }
      const localVarPath =
        `/api/v1/executions/{id.project}/{id.domain}/{id.name}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminExecutionUpdateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates the status of a registered :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {AdminLaunchPlanUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      body: AdminLaunchPlanUpdateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling updateLaunchPlan."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling updateLaunchPlan."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling updateLaunchPlan."
        );
      }
      // verify required parameter 'idVersion' is not null or undefined
      if (idVersion === null || idVersion === undefined) {
        throw new RequiredError(
          "idVersion",
          "Required parameter idVersion was null or undefined when calling updateLaunchPlan."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateLaunchPlan."
        );
      }
      const localVarPath =
        `/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}/{id.version}`
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)))
          .replace(`{${"id.version"}}`, encodeURIComponent(String(idVersion)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminLaunchPlanUpdateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to update +required
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {AdminNamedEntityUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNamedEntity(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminNamedEntityUpdateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'resourceType' is not null or undefined
      if (resourceType === null || resourceType === undefined) {
        throw new RequiredError(
          "resourceType",
          "Required parameter resourceType was null or undefined when calling updateNamedEntity."
        );
      }
      // verify required parameter 'idProject' is not null or undefined
      if (idProject === null || idProject === undefined) {
        throw new RequiredError(
          "idProject",
          "Required parameter idProject was null or undefined when calling updateNamedEntity."
        );
      }
      // verify required parameter 'idDomain' is not null or undefined
      if (idDomain === null || idDomain === undefined) {
        throw new RequiredError(
          "idDomain",
          "Required parameter idDomain was null or undefined when calling updateNamedEntity."
        );
      }
      // verify required parameter 'idName' is not null or undefined
      if (idName === null || idName === undefined) {
        throw new RequiredError(
          "idName",
          "Required parameter idName was null or undefined when calling updateNamedEntity."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateNamedEntity."
        );
      }
      const localVarPath =
        `/api/v1/named_entities/{resource_type}/{id.project}/{id.domain}/{id.name}`
          .replace(
            `{${"resource_type"}}`,
            encodeURIComponent(String(resourceType))
          )
          .replace(`{${"id.project"}}`, encodeURIComponent(String(idProject)))
          .replace(`{${"id.domain"}}`, encodeURIComponent(String(idDomain)))
          .replace(`{${"id.name"}}`, encodeURIComponent(String(idName)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminNamedEntityUpdateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates an existing :ref:`ref_flyteidl.admin.Project`  flyteidl.admin.Project should be passed but the domains property should be empty; it will be ignored in the handler as domains cannot be updated via this API.
     * @param {string} id Globally unique project name.
     * @param {AdminProject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(
      id: string,
      body: AdminProject,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling updateProject."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateProject."
        );
      }
      const localVarPath = `/api/v1/projects/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminProject" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` at the project level
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {AdminProjectAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectAttributes(
      attributesProject: string,
      body: AdminProjectAttributesUpdateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'attributesProject' is not null or undefined
      if (attributesProject === null || attributesProject === undefined) {
        throw new RequiredError(
          "attributesProject",
          "Required parameter attributesProject was null or undefined when calling updateProjectAttributes."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateProjectAttributes."
        );
      }
      const localVarPath =
        `/api/v1/project_attributes/{attributes.project}`.replace(
          `{${"attributes.project"}}`,
          encodeURIComponent(String(attributesProject))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminProjectAttributesUpdateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param {AdminProjectDomainAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectDomainAttributes(
      attributesProject: string,
      attributesDomain: string,
      body: AdminProjectDomainAttributesUpdateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'attributesProject' is not null or undefined
      if (attributesProject === null || attributesProject === undefined) {
        throw new RequiredError(
          "attributesProject",
          "Required parameter attributesProject was null or undefined when calling updateProjectDomainAttributes."
        );
      }
      // verify required parameter 'attributesDomain' is not null or undefined
      if (attributesDomain === null || attributesDomain === undefined) {
        throw new RequiredError(
          "attributesDomain",
          "Required parameter attributesDomain was null or undefined when calling updateProjectDomainAttributes."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateProjectDomainAttributes."
        );
      }
      const localVarPath =
        `/api/v1/project_domain_attributes/{attributes.project}/{attributes.domain}`
          .replace(
            `{${"attributes.project"}}`,
            encodeURIComponent(String(attributesProject))
          )
          .replace(
            `{${"attributes.domain"}}`,
            encodeURIComponent(String(attributesDomain))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminProjectDomainAttributesUpdateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param {string} attributesWorkflow Workflow name for which this set of attributes will be applied.
     * @param {AdminWorkflowAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWorkflowAttributes(
      attributesProject: string,
      attributesDomain: string,
      attributesWorkflow: string,
      body: AdminWorkflowAttributesUpdateRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'attributesProject' is not null or undefined
      if (attributesProject === null || attributesProject === undefined) {
        throw new RequiredError(
          "attributesProject",
          "Required parameter attributesProject was null or undefined when calling updateWorkflowAttributes."
        );
      }
      // verify required parameter 'attributesDomain' is not null or undefined
      if (attributesDomain === null || attributesDomain === undefined) {
        throw new RequiredError(
          "attributesDomain",
          "Required parameter attributesDomain was null or undefined when calling updateWorkflowAttributes."
        );
      }
      // verify required parameter 'attributesWorkflow' is not null or undefined
      if (attributesWorkflow === null || attributesWorkflow === undefined) {
        throw new RequiredError(
          "attributesWorkflow",
          "Required parameter attributesWorkflow was null or undefined when calling updateWorkflowAttributes."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateWorkflowAttributes."
        );
      }
      const localVarPath =
        `/api/v1/workflow_attributes/{attributes.project}/{attributes.domain}/{attributes.workflow}`
          .replace(
            `{${"attributes.project"}}`,
            encodeURIComponent(String(attributesProject))
          )
          .replace(
            `{${"attributes.domain"}}`,
            encodeURIComponent(String(attributesDomain))
          )
          .replace(
            `{${"attributes.workflow"}}`,
            encodeURIComponent(String(attributesWorkflow))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AdminWorkflowAttributesUpdateRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminServiceApi - functional programming interface
 * @export
 */
export const AdminServiceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Triggers the creation of a :ref:`ref_flyteidl.admin.Execution`
     * @param {AdminExecutionCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExecution(
      body: AdminExecutionCreateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminExecutionCreateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).createExecution(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.LaunchPlan` definition
     * @param {AdminLaunchPlanCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLaunchPlan(
      body: AdminLaunchPlanCreateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminLaunchPlanCreateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).createLaunchPlan(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.NodeExecutionEvent` has occurred.
     * @param {AdminNodeExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNodeEvent(
      body: AdminNodeExecutionEventRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNodeExecutionEventResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).createNodeEvent(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Task` definition
     * @param {FlyteidladminTaskCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTask(
      body: FlyteidladminTaskCreateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<FlyteidladminTaskCreateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).createTask(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.TaskExecutionEvent` has occurred.
     * @param {AdminTaskExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskEvent(
      body: AdminTaskExecutionEventRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminTaskExecutionEventResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).createTaskEvent(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Workflow` definition
     * @param {AdminWorkflowCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkflow(
      body: AdminWorkflowCreateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminWorkflowCreateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).createWorkflow(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.WorkflowExecutionEvent` has occurred.
     * @param {AdminWorkflowExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkflowEvent(
      body: AdminWorkflowExecutionEventRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminWorkflowExecutionEventResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).createWorkflowEvent(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {AdminProjectAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectAttributes(
      project: string,
      body: AdminProjectAttributesDeleteRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectAttributesDeleteResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).deleteProjectAttributes(project, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {AdminProjectDomainAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectDomainAttributes(
      project: string,
      domain: string,
      body: AdminProjectDomainAttributesDeleteRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectDomainAttributesDeleteResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).deleteProjectDomainAttributes(project, domain, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {string} workflow Workflow name which this set of attributes references. +required
     * @param {AdminWorkflowAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkflowAttributes(
      project: string,
      domain: string,
      workflow: string,
      body: AdminWorkflowAttributesDeleteRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminWorkflowAttributesDeleteResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).deleteWorkflowAttributes(project, domain, workflow, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch the active version of a :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminLaunchPlan> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getActiveLaunchPlan(idProject, idDomain, idName, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.DescriptionEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} idResourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDescriptionEntity(
      idResourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminDescriptionEntity> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getDescriptionEntity(
        idResourceType,
        idProject,
        idDomain,
        idName,
        idVersion,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminExecution> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getExecution(idProject, idDomain, idName, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutionData(
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminWorkflowExecutionGetDataResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getExecutionData(idProject, idDomain, idName, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches runtime metrics for a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {number} [depth] depth defines the number of Flyte entity levels to traverse when breaking down execution details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutionMetrics(
      idProject: string,
      idDomain: string,
      idName: string,
      depth?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminWorkflowExecutionGetMetricsResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getExecutionMetrics(idProject, idDomain, idName, depth, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.LaunchPlan` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminLaunchPlan> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getLaunchPlan(
        idProject,
        idDomain,
        idName,
        idVersion,
        idResourceType,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Returns a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to get. One of Task, Workflow or LaunchPlan. +required
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNamedEntity(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminNamedEntity> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getNamedEntity(resourceType, idProject, idDomain, idName, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} idExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeExecution(
      idExecutionIdProject: string,
      idExecutionIdDomain: string,
      idExecutionIdName: string,
      idNodeId: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<FlyteidladminNodeExecution> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getNodeExecution(
        idExecutionIdProject,
        idExecutionIdDomain,
        idExecutionIdName,
        idNodeId,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} idExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeExecutionData(
      idExecutionIdProject: string,
      idExecutionIdDomain: string,
      idExecutionIdName: string,
      idNodeId: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNodeExecutionGetDataResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getNodeExecutionData(
        idExecutionIdProject,
        idExecutionIdDomain,
        idExecutionIdName,
        idNodeId,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectAttributes(
      project: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectAttributesGetResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getProjectAttributes(project, resourceType, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDomainAttributes(
      project: string,
      domain: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectDomainAttributesGetResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getProjectDomainAttributes(project, domain, resourceType, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.Task` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminTask> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getTask(
        idProject,
        idDomain,
        idName,
        idVersion,
        idResourceType,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeExecutionIdNodeId
     * @param {string} idTaskIdProject Name of the project the resource belongs to.
     * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idTaskIdName User provided value for the resource.
     * @param {string} idTaskIdVersion Specific version of the resource.
     * @param {number} idRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskExecution(
      idNodeExecutionIdExecutionIdProject: string,
      idNodeExecutionIdExecutionIdDomain: string,
      idNodeExecutionIdExecutionIdName: string,
      idNodeExecutionIdNodeId: string,
      idTaskIdProject: string,
      idTaskIdDomain: string,
      idTaskIdName: string,
      idTaskIdVersion: string,
      idRetryAttempt: number,
      idTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<FlyteidladminTaskExecution> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getTaskExecution(
        idNodeExecutionIdExecutionIdProject,
        idNodeExecutionIdExecutionIdDomain,
        idNodeExecutionIdExecutionIdName,
        idNodeExecutionIdNodeId,
        idTaskIdProject,
        idTaskIdDomain,
        idTaskIdName,
        idTaskIdVersion,
        idRetryAttempt,
        idTaskIdResourceType,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeExecutionIdNodeId
     * @param {string} idTaskIdProject Name of the project the resource belongs to.
     * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idTaskIdName User provided value for the resource.
     * @param {string} idTaskIdVersion Specific version of the resource.
     * @param {number} idRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskExecutionData(
      idNodeExecutionIdExecutionIdProject: string,
      idNodeExecutionIdExecutionIdDomain: string,
      idNodeExecutionIdExecutionIdName: string,
      idNodeExecutionIdNodeId: string,
      idTaskIdProject: string,
      idTaskIdDomain: string,
      idTaskIdName: string,
      idTaskIdVersion: string,
      idRetryAttempt: number,
      idTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminTaskExecutionGetDataResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getTaskExecutionData(
        idNodeExecutionIdExecutionIdProject,
        idNodeExecutionIdExecutionIdDomain,
        idNodeExecutionIdExecutionIdName,
        idNodeExecutionIdNodeId,
        idTaskIdProject,
        idTaskIdDomain,
        idTaskIdName,
        idTaskIdVersion,
        idRetryAttempt,
        idTaskIdResourceType,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminGetVersionResponse> {
      const localVarFetchArgs =
        AdminServiceApiFetchParamCreator(configuration).getVersion(options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.Workflow` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflow(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminWorkflow> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getWorkflow(
        idProject,
        idDomain,
        idName,
        idVersion,
        idResourceType,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {string} workflow Workflow name which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflowAttributes(
      project: string,
      domain: string,
      workflow: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminWorkflowAttributesGetResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).getWorkflowAttributes(project, domain, workflow, resourceType, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary List active versions of :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} project Name of the project that contains the identifiers. +required.
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listActiveLaunchPlans(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminLaunchPlanList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listActiveLaunchPlans(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDescriptionEntities(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminDescriptionEntityList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listDescriptionEntities(
        resourceType,
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDescriptionEntities2(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminDescriptionEntityList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listDescriptionEntities2(
        resourceType,
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExecutions(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminExecutionList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listExecutions(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of launch plan objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlanIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNamedEntityIdentifierList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listLaunchPlanIds(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlans(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminLaunchPlanList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listLaunchPlans(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlans2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminLaunchPlanList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listLaunchPlans2(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Lists custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a specific resource type.
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMatchableAttributes(
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminListMatchableAttributesResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listMatchableAttributes(resourceType, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Returns a list of :ref:`ref_flyteidl.admin.NamedEntity` objects.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to query. One of Task, Workflow or LaunchPlan. +required
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project.
     * @param {number} [limit] Indicates the number of resources to be returned.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNamedEntities(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminNamedEntityList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listNamedEntities(
        resourceType,
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} workflowExecutionIdProject Name of the project the resource belongs to.
     * @param {string} workflowExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} workflowExecutionIdName User or system provided value for the resource.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token]
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [uniqueParentId] Unique identifier of the parent node in the execution +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeExecutions(
      workflowExecutionIdProject: string,
      workflowExecutionIdDomain: string,
      workflowExecutionIdName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      uniqueParentId?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNodeExecutionList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listNodeExecutions(
        workflowExecutionIdProject,
        workflowExecutionIdDomain,
        workflowExecutionIdName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        uniqueParentId,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution` launched by the reference :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} taskExecutionIdNodeExecutionIdNodeId
     * @param {string} taskExecutionIdTaskIdProject Name of the project the resource belongs to.
     * @param {string} taskExecutionIdTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} taskExecutionIdTaskIdName User provided value for the resource.
     * @param {string} taskExecutionIdTaskIdVersion Specific version of the resource.
     * @param {number} taskExecutionIdRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [taskExecutionIdTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the, server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeExecutionsForTask(
      taskExecutionIdNodeExecutionIdExecutionIdProject: string,
      taskExecutionIdNodeExecutionIdExecutionIdDomain: string,
      taskExecutionIdNodeExecutionIdExecutionIdName: string,
      taskExecutionIdNodeExecutionIdNodeId: string,
      taskExecutionIdTaskIdProject: string,
      taskExecutionIdTaskIdDomain: string,
      taskExecutionIdTaskIdName: string,
      taskExecutionIdTaskIdVersion: string,
      taskExecutionIdRetryAttempt: number,
      taskExecutionIdTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNodeExecutionList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listNodeExecutionsForTask(
        taskExecutionIdNodeExecutionIdExecutionIdProject,
        taskExecutionIdNodeExecutionIdExecutionIdDomain,
        taskExecutionIdNodeExecutionIdExecutionIdName,
        taskExecutionIdNodeExecutionIdNodeId,
        taskExecutionIdTaskIdProject,
        taskExecutionIdTaskIdDomain,
        taskExecutionIdTaskIdName,
        taskExecutionIdTaskIdVersion,
        taskExecutionIdRetryAttempt,
        taskExecutionIdTaskIdResourceType,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.Project`
     * @param {number} [limit] Indicates the number of projects to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects(
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminProjects> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listProjects(
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} nodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} nodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} nodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} nodeExecutionIdNodeId
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskExecutions(
      nodeExecutionIdExecutionIdProject: string,
      nodeExecutionIdExecutionIdDomain: string,
      nodeExecutionIdExecutionIdName: string,
      nodeExecutionIdNodeId: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminTaskExecutionList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listTaskExecutions(
        nodeExecutionIdExecutionIdProject,
        nodeExecutionIdExecutionIdDomain,
        nodeExecutionIdExecutionIdName,
        nodeExecutionIdNodeId,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of task objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNamedEntityIdentifierList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listTaskIds(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTasks(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminTaskList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listTasks(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTasks2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminTaskList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listTasks2(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of workflow objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflowIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNamedEntityIdentifierList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listWorkflowIds(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflows(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminWorkflowList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listWorkflows(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflows2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AdminWorkflowList> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).listWorkflows2(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Recreates a previously-run workflow execution that will only start executing from the last known failure point. In Recover mode, users cannot change any input parameters or update the version of the execution. This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures, downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again. See :ref:`ref_flyteidl.admin.ExecutionRecoverRequest` for more details.
     * @param {AdminExecutionRecoverRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recoverExecution(
      body: AdminExecutionRecoverRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminExecutionCreateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).recoverExecution(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Registers a :ref:`ref_flyteidl.admin.Project` with the Flyte deployment.
     * @param {AdminProjectRegisterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerProject(
      body: AdminProjectRegisterRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectRegisterResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).registerProject(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Triggers the creation of an identical :ref:`ref_flyteidl.admin.Execution`
     * @param {AdminExecutionRelaunchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relaunchExecution(
      body: AdminExecutionRelaunchRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminExecutionCreateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).relaunchExecution(body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Terminates an in-progress :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {AdminExecutionTerminateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminExecutionTerminateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminExecutionTerminateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).terminateExecution(idProject, idDomain, idName, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update execution belonging to project domain :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {AdminExecutionUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminExecutionUpdateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminExecutionUpdateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).updateExecution(idProject, idDomain, idName, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Updates the status of a registered :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {AdminLaunchPlanUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      body: AdminLaunchPlanUpdateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminLaunchPlanUpdateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).updateLaunchPlan(idProject, idDomain, idName, idVersion, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Updates a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to update +required
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {AdminNamedEntityUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNamedEntity(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminNamedEntityUpdateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminNamedEntityUpdateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).updateNamedEntity(
        resourceType,
        idProject,
        idDomain,
        idName,
        body,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Updates an existing :ref:`ref_flyteidl.admin.Project`  flyteidl.admin.Project should be passed but the domains property should be empty; it will be ignored in the handler as domains cannot be updated via this API.
     * @param {string} id Globally unique project name.
     * @param {AdminProject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(
      id: string,
      body: AdminProject,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectUpdateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).updateProject(id, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` at the project level
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {AdminProjectAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectAttributes(
      attributesProject: string,
      body: AdminProjectAttributesUpdateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectAttributesUpdateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).updateProjectAttributes(attributesProject, body, options);
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param {AdminProjectDomainAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectDomainAttributes(
      attributesProject: string,
      attributesDomain: string,
      body: AdminProjectDomainAttributesUpdateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminProjectDomainAttributesUpdateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).updateProjectDomainAttributes(
        attributesProject,
        attributesDomain,
        body,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param {string} attributesWorkflow Workflow name for which this set of attributes will be applied.
     * @param {AdminWorkflowAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWorkflowAttributes(
      attributesProject: string,
      attributesDomain: string,
      attributesWorkflow: string,
      body: AdminWorkflowAttributesUpdateRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AdminWorkflowAttributesUpdateResponse> {
      const localVarFetchArgs = AdminServiceApiFetchParamCreator(
        configuration
      ).updateWorkflowAttributes(
        attributesProject,
        attributesDomain,
        attributesWorkflow,
        body,
        options
      );
      return (fetch: FetchAPI = crossFetch, basePath: string = BASE_PATH) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AdminServiceApi - factory interface
 * @export
 */
export const AdminServiceApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Triggers the creation of a :ref:`ref_flyteidl.admin.Execution`
     * @param {AdminExecutionCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExecution(body: AdminExecutionCreateRequest, options?: any) {
      return AdminServiceApiFp(configuration).createExecution(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.LaunchPlan` definition
     * @param {AdminLaunchPlanCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLaunchPlan(body: AdminLaunchPlanCreateRequest, options?: any) {
      return AdminServiceApiFp(configuration).createLaunchPlan(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.NodeExecutionEvent` has occurred.
     * @param {AdminNodeExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNodeEvent(body: AdminNodeExecutionEventRequest, options?: any) {
      return AdminServiceApiFp(configuration).createNodeEvent(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Task` definition
     * @param {FlyteidladminTaskCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTask(body: FlyteidladminTaskCreateRequest, options?: any) {
      return AdminServiceApiFp(configuration).createTask(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.TaskExecutionEvent` has occurred.
     * @param {AdminTaskExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskEvent(body: AdminTaskExecutionEventRequest, options?: any) {
      return AdminServiceApiFp(configuration).createTaskEvent(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Workflow` definition
     * @param {AdminWorkflowCreateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkflow(body: AdminWorkflowCreateRequest, options?: any) {
      return AdminServiceApiFp(configuration).createWorkflow(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Indicates a :ref:`ref_flyteidl.event.WorkflowExecutionEvent` has occurred.
     * @param {AdminWorkflowExecutionEventRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkflowEvent(
      body: AdminWorkflowExecutionEventRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).createWorkflowEvent(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {AdminProjectAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectAttributes(
      project: string,
      body: AdminProjectAttributesDeleteRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).deleteProjectAttributes(
        project,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {AdminProjectDomainAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProjectDomainAttributes(
      project: string,
      domain: string,
      body: AdminProjectDomainAttributesDeleteRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).deleteProjectDomainAttributes(
        project,
        domain,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {string} workflow Workflow name which this set of attributes references. +required
     * @param {AdminWorkflowAttributesDeleteRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkflowAttributes(
      project: string,
      domain: string,
      workflow: string,
      body: AdminWorkflowAttributesDeleteRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).deleteWorkflowAttributes(
        project,
        domain,
        workflow,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch the active version of a :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getActiveLaunchPlan(
        idProject,
        idDomain,
        idName,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.DescriptionEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} idResourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDescriptionEntity(
      idResourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getDescriptionEntity(
        idResourceType,
        idProject,
        idDomain,
        idName,
        idVersion,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getExecution(
        idProject,
        idDomain,
        idName,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutionData(
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getExecutionData(
        idProject,
        idDomain,
        idName,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches runtime metrics for a :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {number} [depth] depth defines the number of Flyte entity levels to traverse when breaking down execution details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutionMetrics(
      idProject: string,
      idDomain: string,
      idName: string,
      depth?: number,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getExecutionMetrics(
        idProject,
        idDomain,
        idName,
        depth,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.LaunchPlan` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getLaunchPlan(
        idProject,
        idDomain,
        idName,
        idVersion,
        idResourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Returns a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to get. One of Task, Workflow or LaunchPlan. +required
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNamedEntity(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getNamedEntity(
        resourceType,
        idProject,
        idDomain,
        idName,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} idExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeExecution(
      idExecutionIdProject: string,
      idExecutionIdDomain: string,
      idExecutionIdName: string,
      idNodeId: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getNodeExecution(
        idExecutionIdProject,
        idExecutionIdDomain,
        idExecutionIdName,
        idNodeId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} idExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeExecutionData(
      idExecutionIdProject: string,
      idExecutionIdDomain: string,
      idExecutionIdName: string,
      idNodeId: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getNodeExecutionData(
        idExecutionIdProject,
        idExecutionIdDomain,
        idExecutionIdName,
        idNodeId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectAttributes(
      project: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getProjectAttributes(
        project,
        resourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDomainAttributes(
      project: string,
      domain: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getProjectDomainAttributes(
        project,
        domain,
        resourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.Task` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTask(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getTask(
        idProject,
        idDomain,
        idName,
        idVersion,
        idResourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeExecutionIdNodeId
     * @param {string} idTaskIdProject Name of the project the resource belongs to.
     * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idTaskIdName User provided value for the resource.
     * @param {string} idTaskIdVersion Specific version of the resource.
     * @param {number} idRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskExecution(
      idNodeExecutionIdExecutionIdProject: string,
      idNodeExecutionIdExecutionIdDomain: string,
      idNodeExecutionIdExecutionIdName: string,
      idNodeExecutionIdNodeId: string,
      idTaskIdProject: string,
      idTaskIdDomain: string,
      idTaskIdName: string,
      idTaskIdVersion: string,
      idRetryAttempt: number,
      idTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getTaskExecution(
        idNodeExecutionIdExecutionIdProject,
        idNodeExecutionIdExecutionIdDomain,
        idNodeExecutionIdExecutionIdName,
        idNodeExecutionIdNodeId,
        idTaskIdProject,
        idTaskIdDomain,
        idTaskIdName,
        idTaskIdVersion,
        idRetryAttempt,
        idTaskIdResourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} idNodeExecutionIdNodeId
     * @param {string} idTaskIdProject Name of the project the resource belongs to.
     * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idTaskIdName User provided value for the resource.
     * @param {string} idTaskIdVersion Specific version of the resource.
     * @param {number} idRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskExecutionData(
      idNodeExecutionIdExecutionIdProject: string,
      idNodeExecutionIdExecutionIdDomain: string,
      idNodeExecutionIdExecutionIdName: string,
      idNodeExecutionIdNodeId: string,
      idTaskIdProject: string,
      idTaskIdDomain: string,
      idTaskIdName: string,
      idTaskIdVersion: string,
      idRetryAttempt: number,
      idTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getTaskExecutionData(
        idNodeExecutionIdExecutionIdProject,
        idNodeExecutionIdExecutionIdDomain,
        idNodeExecutionIdExecutionIdName,
        idNodeExecutionIdNodeId,
        idTaskIdProject,
        idTaskIdDomain,
        idTaskIdName,
        idTaskIdVersion,
        idRetryAttempt,
        idTaskIdResourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options?: any) {
      return AdminServiceApiFp(configuration).getVersion(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Fetch a :ref:`ref_flyteidl.admin.Workflow` definition.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflow(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      idResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getWorkflow(
        idProject,
        idDomain,
        idName,
        idVersion,
        idResourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} project Unique project id which this set of attributes references. +required
     * @param {string} domain Unique domain id which this set of attributes references. +required
     * @param {string} workflow Workflow name which this set of attributes references. +required
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkflowAttributes(
      project: string,
      domain: string,
      workflow: string,
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).getWorkflowAttributes(
        project,
        domain,
        workflow,
        resourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary List active versions of :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} project Name of the project that contains the identifiers. +required.
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listActiveLaunchPlans(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listActiveLaunchPlans(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDescriptionEntities(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listDescriptionEntities(
        resourceType,
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDescriptionEntities2(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listDescriptionEntities2(
        resourceType,
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExecutions(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listExecutions(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of launch plan objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlanIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listLaunchPlanIds(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlans(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listLaunchPlans(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLaunchPlans2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listLaunchPlans2(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Lists custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a specific resource type.
     * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMatchableAttributes(
      resourceType?:
        | "TASK_RESOURCE"
        | "CLUSTER_RESOURCE"
        | "EXECUTION_QUEUE"
        | "EXECUTION_CLUSTER_LABEL"
        | "QUALITY_OF_SERVICE_SPECIFICATION"
        | "PLUGIN_OVERRIDE"
        | "WORKFLOW_EXECUTION_CONFIG"
        | "CLUSTER_ASSIGNMENT",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listMatchableAttributes(
        resourceType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Returns a list of :ref:`ref_flyteidl.admin.NamedEntity` objects.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to query. One of Task, Workflow or LaunchPlan. +required
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project.
     * @param {number} [limit] Indicates the number of resources to be returned.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNamedEntities(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listNamedEntities(
        resourceType,
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param {string} workflowExecutionIdProject Name of the project the resource belongs to.
     * @param {string} workflowExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} workflowExecutionIdName User or system provided value for the resource.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token]
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [uniqueParentId] Unique identifier of the parent node in the execution +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeExecutions(
      workflowExecutionIdProject: string,
      workflowExecutionIdDomain: string,
      workflowExecutionIdName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      uniqueParentId?: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listNodeExecutions(
        workflowExecutionIdProject,
        workflowExecutionIdDomain,
        workflowExecutionIdName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        uniqueParentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution` launched by the reference :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} taskExecutionIdNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} taskExecutionIdNodeExecutionIdNodeId
     * @param {string} taskExecutionIdTaskIdProject Name of the project the resource belongs to.
     * @param {string} taskExecutionIdTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} taskExecutionIdTaskIdName User provided value for the resource.
     * @param {string} taskExecutionIdTaskIdVersion Specific version of the resource.
     * @param {number} taskExecutionIdRetryAttempt
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [taskExecutionIdTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the, server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeExecutionsForTask(
      taskExecutionIdNodeExecutionIdExecutionIdProject: string,
      taskExecutionIdNodeExecutionIdExecutionIdDomain: string,
      taskExecutionIdNodeExecutionIdExecutionIdName: string,
      taskExecutionIdNodeExecutionIdNodeId: string,
      taskExecutionIdTaskIdProject: string,
      taskExecutionIdTaskIdDomain: string,
      taskExecutionIdTaskIdName: string,
      taskExecutionIdTaskIdVersion: string,
      taskExecutionIdRetryAttempt: number,
      taskExecutionIdTaskIdResourceType?:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listNodeExecutionsForTask(
        taskExecutionIdNodeExecutionIdExecutionIdProject,
        taskExecutionIdNodeExecutionIdExecutionIdDomain,
        taskExecutionIdNodeExecutionIdExecutionIdName,
        taskExecutionIdNodeExecutionIdNodeId,
        taskExecutionIdTaskIdProject,
        taskExecutionIdTaskIdDomain,
        taskExecutionIdTaskIdName,
        taskExecutionIdTaskIdVersion,
        taskExecutionIdRetryAttempt,
        taskExecutionIdTaskIdResourceType,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.Project`
     * @param {number} [limit] Indicates the number of projects to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects(
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listProjects(
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param {string} nodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param {string} nodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} nodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param {string} nodeExecutionIdNodeId
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskExecutions(
      nodeExecutionIdExecutionIdProject: string,
      nodeExecutionIdExecutionIdDomain: string,
      nodeExecutionIdExecutionIdName: string,
      nodeExecutionIdNodeId: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listTaskExecutions(
        nodeExecutionIdExecutionIdProject,
        nodeExecutionIdExecutionIdDomain,
        nodeExecutionIdExecutionIdName,
        nodeExecutionIdNodeId,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of task objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listTaskIds(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTasks(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listTasks(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTasks2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listTasks2(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of workflow objects.
     * @param {string} project Name of the project that contains the identifiers. +required
     * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {string} [filters] Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflowIds(
      project: string,
      domain: string,
      limit?: number,
      token?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      filters?: string,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listWorkflowIds(
        project,
        domain,
        limit,
        token,
        sortByKey,
        sortByDirection,
        filters,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflows(
      idProject: string,
      idDomain: string,
      idName: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listWorkflows(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param {number} [limit] Indicates the number of resources to be returned. +required.
     * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
     * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkflows2(
      idProject: string,
      idDomain: string,
      idName?: string,
      limit?: number,
      token?: string,
      filters?: string,
      sortByKey?: string,
      sortByDirection?: "DESCENDING" | "ASCENDING",
      options?: any
    ) {
      return AdminServiceApiFp(configuration).listWorkflows2(
        idProject,
        idDomain,
        idName,
        limit,
        token,
        filters,
        sortByKey,
        sortByDirection,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Recreates a previously-run workflow execution that will only start executing from the last known failure point. In Recover mode, users cannot change any input parameters or update the version of the execution. This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures, downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again. See :ref:`ref_flyteidl.admin.ExecutionRecoverRequest` for more details.
     * @param {AdminExecutionRecoverRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recoverExecution(body: AdminExecutionRecoverRequest, options?: any) {
      return AdminServiceApiFp(configuration).recoverExecution(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Registers a :ref:`ref_flyteidl.admin.Project` with the Flyte deployment.
     * @param {AdminProjectRegisterRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerProject(body: AdminProjectRegisterRequest, options?: any) {
      return AdminServiceApiFp(configuration).registerProject(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Triggers the creation of an identical :ref:`ref_flyteidl.admin.Execution`
     * @param {AdminExecutionRelaunchRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relaunchExecution(body: AdminExecutionRelaunchRequest, options?: any) {
      return AdminServiceApiFp(configuration).relaunchExecution(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Terminates an in-progress :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {AdminExecutionTerminateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    terminateExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminExecutionTerminateRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).terminateExecution(
        idProject,
        idDomain,
        idName,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update execution belonging to project domain :ref:`ref_flyteidl.admin.Execution`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User or system provided value for the resource.
     * @param {AdminExecutionUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExecution(
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminExecutionUpdateRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).updateExecution(
        idProject,
        idDomain,
        idName,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Updates the status of a registered :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource.
     * @param {string} idVersion Specific version of the resource.
     * @param {AdminLaunchPlanUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLaunchPlan(
      idProject: string,
      idDomain: string,
      idName: string,
      idVersion: string,
      body: AdminLaunchPlanUpdateRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).updateLaunchPlan(
        idProject,
        idDomain,
        idName,
        idVersion,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Updates a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to update +required
     * @param {string} idProject Name of the project the resource belongs to.
     * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {AdminNamedEntityUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNamedEntity(
      resourceType:
        | "UNSPECIFIED"
        | "TASK"
        | "WORKFLOW"
        | "LAUNCH_PLAN"
        | "DATASET",
      idProject: string,
      idDomain: string,
      idName: string,
      body: AdminNamedEntityUpdateRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).updateNamedEntity(
        resourceType,
        idProject,
        idDomain,
        idName,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Updates an existing :ref:`ref_flyteidl.admin.Project`  flyteidl.admin.Project should be passed but the domains property should be empty; it will be ignored in the handler as domains cannot be updated via this API.
     * @param {string} id Globally unique project name.
     * @param {AdminProject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(id: string, body: AdminProject, options?: any) {
      return AdminServiceApiFp(configuration).updateProject(
        id,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` at the project level
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {AdminProjectAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectAttributes(
      attributesProject: string,
      body: AdminProjectAttributesUpdateRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).updateProjectAttributes(
        attributesProject,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param {AdminProjectDomainAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProjectDomainAttributes(
      attributesProject: string,
      attributesDomain: string,
      body: AdminProjectDomainAttributesUpdateRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).updateProjectDomainAttributes(
        attributesProject,
        attributesDomain,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
     * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param {string} attributesWorkflow Workflow name for which this set of attributes will be applied.
     * @param {AdminWorkflowAttributesUpdateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWorkflowAttributes(
      attributesProject: string,
      attributesDomain: string,
      attributesWorkflow: string,
      body: AdminWorkflowAttributesUpdateRequest,
      options?: any
    ) {
      return AdminServiceApiFp(configuration).updateWorkflowAttributes(
        attributesProject,
        attributesDomain,
        attributesWorkflow,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * AdminServiceApi - object-oriented interface
 * @export
 * @class AdminServiceApi
 * @extends {BaseAPI}
 */
export class AdminServiceApi extends BaseAPI {
  /**
   *
   * @summary Triggers the creation of a :ref:`ref_flyteidl.admin.Execution`
   * @param {AdminExecutionCreateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public createExecution(body: AdminExecutionCreateRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).createExecution(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Create and upload a :ref:`ref_flyteidl.admin.LaunchPlan` definition
   * @param {AdminLaunchPlanCreateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public createLaunchPlan(body: AdminLaunchPlanCreateRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).createLaunchPlan(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Indicates a :ref:`ref_flyteidl.event.NodeExecutionEvent` has occurred.
   * @param {AdminNodeExecutionEventRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public createNodeEvent(body: AdminNodeExecutionEventRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).createNodeEvent(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Create and upload a :ref:`ref_flyteidl.admin.Task` definition
   * @param {FlyteidladminTaskCreateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public createTask(body: FlyteidladminTaskCreateRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).createTask(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Indicates a :ref:`ref_flyteidl.event.TaskExecutionEvent` has occurred.
   * @param {AdminTaskExecutionEventRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public createTaskEvent(body: AdminTaskExecutionEventRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).createTaskEvent(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Create and upload a :ref:`ref_flyteidl.admin.Workflow` definition
   * @param {AdminWorkflowCreateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public createWorkflow(body: AdminWorkflowCreateRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).createWorkflow(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Indicates a :ref:`ref_flyteidl.event.WorkflowExecutionEvent` has occurred.
   * @param {AdminWorkflowExecutionEventRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public createWorkflowEvent(
    body: AdminWorkflowExecutionEventRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).createWorkflowEvent(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
   * @param {string} project Unique project id which this set of attributes references. +required
   * @param {AdminProjectAttributesDeleteRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public deleteProjectAttributes(
    project: string,
    body: AdminProjectAttributesDeleteRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).deleteProjectAttributes(
      project,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
   * @param {string} project Unique project id which this set of attributes references. +required
   * @param {string} domain Unique domain id which this set of attributes references. +required
   * @param {AdminProjectDomainAttributesDeleteRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public deleteProjectDomainAttributes(
    project: string,
    domain: string,
    body: AdminProjectDomainAttributesDeleteRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).deleteProjectDomainAttributes(
      project,
      domain,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
   * @param {string} project Unique project id which this set of attributes references. +required
   * @param {string} domain Unique domain id which this set of attributes references. +required
   * @param {string} workflow Workflow name which this set of attributes references. +required
   * @param {AdminWorkflowAttributesDeleteRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public deleteWorkflowAttributes(
    project: string,
    domain: string,
    workflow: string,
    body: AdminWorkflowAttributesDeleteRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).deleteWorkflowAttributes(
      project,
      domain,
      workflow,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch the active version of a :ref:`ref_flyteidl.admin.LaunchPlan`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getActiveLaunchPlan(
    idProject: string,
    idDomain: string,
    idName: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getActiveLaunchPlan(
      idProject,
      idDomain,
      idName,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a :ref:`ref_flyteidl.admin.DescriptionEntity` object.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} idResourceType Identifies the specific type of resource that this identifier corresponds to.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource.
   * @param {string} idVersion Specific version of the resource.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getDescriptionEntity(
    idResourceType:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    idProject: string,
    idDomain: string,
    idName: string,
    idVersion: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getDescriptionEntity(
      idResourceType,
      idProject,
      idDomain,
      idName,
      idVersion,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches a :ref:`ref_flyteidl.admin.Execution`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User or system provided value for the resource.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getExecution(
    idProject: string,
    idDomain: string,
    idName: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getExecution(
      idProject,
      idDomain,
      idName,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.Execution`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User or system provided value for the resource.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getExecutionData(
    idProject: string,
    idDomain: string,
    idName: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getExecutionData(
      idProject,
      idDomain,
      idName,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches runtime metrics for a :ref:`ref_flyteidl.admin.Execution`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User or system provided value for the resource.
   * @param {number} [depth] depth defines the number of Flyte entity levels to traverse when breaking down execution details.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getExecutionMetrics(
    idProject: string,
    idDomain: string,
    idName: string,
    depth?: number,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getExecutionMetrics(
      idProject,
      idDomain,
      idName,
      depth,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a :ref:`ref_flyteidl.admin.LaunchPlan` definition.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource.
   * @param {string} idVersion Specific version of the resource.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getLaunchPlan(
    idProject: string,
    idDomain: string,
    idName: string,
    idVersion: string,
    idResourceType?:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getLaunchPlan(
      idProject,
      idDomain,
      idName,
      idVersion,
      idResourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Returns a :ref:`ref_flyteidl.admin.NamedEntity` object.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to get. One of Task, Workflow or LaunchPlan. +required
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getNamedEntity(
    resourceType:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    idProject: string,
    idDomain: string,
    idName: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getNamedEntity(
      resourceType,
      idProject,
      idDomain,
      idName,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches a :ref:`ref_flyteidl.admin.NodeExecution`.
   * @param {string} idExecutionIdProject Name of the project the resource belongs to.
   * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idExecutionIdName User or system provided value for the resource.
   * @param {string} idNodeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getNodeExecution(
    idExecutionIdProject: string,
    idExecutionIdDomain: string,
    idExecutionIdName: string,
    idNodeId: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getNodeExecution(
      idExecutionIdProject,
      idExecutionIdDomain,
      idExecutionIdName,
      idNodeId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.NodeExecution`.
   * @param {string} idExecutionIdProject Name of the project the resource belongs to.
   * @param {string} idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idExecutionIdName User or system provided value for the resource.
   * @param {string} idNodeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getNodeExecutionData(
    idExecutionIdProject: string,
    idExecutionIdDomain: string,
    idExecutionIdName: string,
    idNodeId: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getNodeExecutionData(
      idExecutionIdProject,
      idExecutionIdDomain,
      idExecutionIdName,
      idNodeId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
   * @param {string} project Unique project id which this set of attributes references. +required
   * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getProjectAttributes(
    project: string,
    resourceType?:
      | "TASK_RESOURCE"
      | "CLUSTER_RESOURCE"
      | "EXECUTION_QUEUE"
      | "EXECUTION_CLUSTER_LABEL"
      | "QUALITY_OF_SERVICE_SPECIFICATION"
      | "PLUGIN_OVERRIDE"
      | "WORKFLOW_EXECUTION_CONFIG"
      | "CLUSTER_ASSIGNMENT",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getProjectAttributes(
      project,
      resourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
   * @param {string} project Unique project id which this set of attributes references. +required
   * @param {string} domain Unique domain id which this set of attributes references. +required
   * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getProjectDomainAttributes(
    project: string,
    domain: string,
    resourceType?:
      | "TASK_RESOURCE"
      | "CLUSTER_RESOURCE"
      | "EXECUTION_QUEUE"
      | "EXECUTION_CLUSTER_LABEL"
      | "QUALITY_OF_SERVICE_SPECIFICATION"
      | "PLUGIN_OVERRIDE"
      | "WORKFLOW_EXECUTION_CONFIG"
      | "CLUSTER_ASSIGNMENT",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getProjectDomainAttributes(
      project,
      domain,
      resourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a :ref:`ref_flyteidl.admin.Task` definition.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource.
   * @param {string} idVersion Specific version of the resource.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getTask(
    idProject: string,
    idDomain: string,
    idName: string,
    idVersion: string,
    idResourceType?:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getTask(
      idProject,
      idDomain,
      idName,
      idVersion,
      idResourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches a :ref:`ref_flyteidl.admin.TaskExecution`.
   * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
   * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
   * @param {string} idNodeExecutionIdNodeId
   * @param {string} idTaskIdProject Name of the project the resource belongs to.
   * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idTaskIdName User provided value for the resource.
   * @param {string} idTaskIdVersion Specific version of the resource.
   * @param {number} idRetryAttempt
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getTaskExecution(
    idNodeExecutionIdExecutionIdProject: string,
    idNodeExecutionIdExecutionIdDomain: string,
    idNodeExecutionIdExecutionIdName: string,
    idNodeExecutionIdNodeId: string,
    idTaskIdProject: string,
    idTaskIdDomain: string,
    idTaskIdName: string,
    idTaskIdVersion: string,
    idRetryAttempt: number,
    idTaskIdResourceType?:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getTaskExecution(
      idNodeExecutionIdExecutionIdProject,
      idNodeExecutionIdExecutionIdDomain,
      idNodeExecutionIdExecutionIdName,
      idNodeExecutionIdNodeId,
      idTaskIdProject,
      idTaskIdDomain,
      idTaskIdName,
      idTaskIdVersion,
      idRetryAttempt,
      idTaskIdResourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.TaskExecution`.
   * @param {string} idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
   * @param {string} idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idNodeExecutionIdExecutionIdName User or system provided value for the resource.
   * @param {string} idNodeExecutionIdNodeId
   * @param {string} idTaskIdProject Name of the project the resource belongs to.
   * @param {string} idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idTaskIdName User provided value for the resource.
   * @param {string} idTaskIdVersion Specific version of the resource.
   * @param {number} idRetryAttempt
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getTaskExecutionData(
    idNodeExecutionIdExecutionIdProject: string,
    idNodeExecutionIdExecutionIdDomain: string,
    idNodeExecutionIdExecutionIdName: string,
    idNodeExecutionIdNodeId: string,
    idTaskIdProject: string,
    idTaskIdDomain: string,
    idTaskIdName: string,
    idTaskIdVersion: string,
    idRetryAttempt: number,
    idTaskIdResourceType?:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getTaskExecutionData(
      idNodeExecutionIdExecutionIdProject,
      idNodeExecutionIdExecutionIdDomain,
      idNodeExecutionIdExecutionIdName,
      idNodeExecutionIdNodeId,
      idTaskIdProject,
      idTaskIdDomain,
      idTaskIdName,
      idTaskIdVersion,
      idRetryAttempt,
      idTaskIdResourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getVersion(options?: any) {
    return AdminServiceApiFp(this.configuration).getVersion(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Fetch a :ref:`ref_flyteidl.admin.Workflow` definition.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource.
   * @param {string} idVersion Specific version of the resource.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [idResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getWorkflow(
    idProject: string,
    idDomain: string,
    idName: string,
    idVersion: string,
    idResourceType?:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getWorkflow(
      idProject,
      idDomain,
      idName,
      idVersion,
      idResourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
   * @param {string} project Unique project id which this set of attributes references. +required
   * @param {string} domain Unique domain id which this set of attributes references. +required
   * @param {string} workflow Workflow name which this set of attributes references. +required
   * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public getWorkflowAttributes(
    project: string,
    domain: string,
    workflow: string,
    resourceType?:
      | "TASK_RESOURCE"
      | "CLUSTER_RESOURCE"
      | "EXECUTION_QUEUE"
      | "EXECUTION_CLUSTER_LABEL"
      | "QUALITY_OF_SERVICE_SPECIFICATION"
      | "PLUGIN_OVERRIDE"
      | "WORKFLOW_EXECUTION_CONFIG"
      | "CLUSTER_ASSIGNMENT",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).getWorkflowAttributes(
      project,
      domain,
      workflow,
      resourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary List active versions of :ref:`ref_flyteidl.admin.LaunchPlan`.
   * @param {string} project Name of the project that contains the identifiers. +required.
   * @param {string} domain Name of the domain the identifiers belongs to within the project. +required.
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listActiveLaunchPlans(
    project: string,
    domain: string,
    limit?: number,
    token?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listActiveLaunchPlans(
      project,
      domain,
      limit,
      token,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listDescriptionEntities(
    resourceType:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    idProject: string,
    idDomain: string,
    idName: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listDescriptionEntities(
      resourceType,
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Identifies the specific type of resource that this identifier corresponds to.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listDescriptionEntities2(
    resourceType:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    idProject: string,
    idDomain: string,
    idName?: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listDescriptionEntities2(
      resourceType,
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.Execution`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listExecutions(
    idProject: string,
    idDomain: string,
    idName?: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listExecutions(
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of launch plan objects.
   * @param {string} project Name of the project that contains the identifiers. +required
   * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {string} [filters] Indicates a list of filters passed as string. +optional.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listLaunchPlanIds(
    project: string,
    domain: string,
    limit?: number,
    token?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    filters?: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listLaunchPlanIds(
      project,
      domain,
      limit,
      token,
      sortByKey,
      sortByDirection,
      filters,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listLaunchPlans(
    idProject: string,
    idDomain: string,
    idName: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listLaunchPlans(
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listLaunchPlans2(
    idProject: string,
    idDomain: string,
    idName?: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listLaunchPlans2(
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Lists custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a specific resource type.
   * @param {'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'} [resourceType] +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listMatchableAttributes(
    resourceType?:
      | "TASK_RESOURCE"
      | "CLUSTER_RESOURCE"
      | "EXECUTION_QUEUE"
      | "EXECUTION_CLUSTER_LABEL"
      | "QUALITY_OF_SERVICE_SPECIFICATION"
      | "PLUGIN_OVERRIDE"
      | "WORKFLOW_EXECUTION_CONFIG"
      | "CLUSTER_ASSIGNMENT",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listMatchableAttributes(
      resourceType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Returns a list of :ref:`ref_flyteidl.admin.NamedEntity` objects.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to query. One of Task, Workflow or LaunchPlan. +required
   * @param {string} project Name of the project that contains the identifiers. +required
   * @param {string} domain Name of the domain the identifiers belongs to within the project.
   * @param {number} [limit] Indicates the number of resources to be returned.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {string} [filters] Indicates a list of filters passed as string. +optional.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listNamedEntities(
    resourceType:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    project: string,
    domain: string,
    limit?: number,
    token?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    filters?: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listNamedEntities(
      resourceType,
      project,
      domain,
      limit,
      token,
      sortByKey,
      sortByDirection,
      filters,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution`.
   * @param {string} workflowExecutionIdProject Name of the project the resource belongs to.
   * @param {string} workflowExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} workflowExecutionIdName User or system provided value for the resource.
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token]
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {string} [uniqueParentId] Unique identifier of the parent node in the execution +optional.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listNodeExecutions(
    workflowExecutionIdProject: string,
    workflowExecutionIdDomain: string,
    workflowExecutionIdName: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    uniqueParentId?: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listNodeExecutions(
      workflowExecutionIdProject,
      workflowExecutionIdDomain,
      workflowExecutionIdName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      uniqueParentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution` launched by the reference :ref:`ref_flyteidl.admin.TaskExecution`.
   * @param {string} taskExecutionIdNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
   * @param {string} taskExecutionIdNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} taskExecutionIdNodeExecutionIdExecutionIdName User or system provided value for the resource.
   * @param {string} taskExecutionIdNodeExecutionIdNodeId
   * @param {string} taskExecutionIdTaskIdProject Name of the project the resource belongs to.
   * @param {string} taskExecutionIdTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} taskExecutionIdTaskIdName User provided value for the resource.
   * @param {string} taskExecutionIdTaskIdVersion Specific version of the resource.
   * @param {number} taskExecutionIdRetryAttempt
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} [taskExecutionIdTaskIdResourceType] Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the, server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listNodeExecutionsForTask(
    taskExecutionIdNodeExecutionIdExecutionIdProject: string,
    taskExecutionIdNodeExecutionIdExecutionIdDomain: string,
    taskExecutionIdNodeExecutionIdExecutionIdName: string,
    taskExecutionIdNodeExecutionIdNodeId: string,
    taskExecutionIdTaskIdProject: string,
    taskExecutionIdTaskIdDomain: string,
    taskExecutionIdTaskIdName: string,
    taskExecutionIdTaskIdVersion: string,
    taskExecutionIdRetryAttempt: number,
    taskExecutionIdTaskIdResourceType?:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listNodeExecutionsForTask(
      taskExecutionIdNodeExecutionIdExecutionIdProject,
      taskExecutionIdNodeExecutionIdExecutionIdDomain,
      taskExecutionIdNodeExecutionIdExecutionIdName,
      taskExecutionIdNodeExecutionIdNodeId,
      taskExecutionIdTaskIdProject,
      taskExecutionIdTaskIdDomain,
      taskExecutionIdTaskIdName,
      taskExecutionIdTaskIdVersion,
      taskExecutionIdRetryAttempt,
      taskExecutionIdTaskIdResourceType,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches a list of :ref:`ref_flyteidl.admin.Project`
   * @param {number} [limit] Indicates the number of projects to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listProjects(
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listProjects(
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetches a list of :ref:`ref_flyteidl.admin.TaskExecution`.
   * @param {string} nodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
   * @param {string} nodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} nodeExecutionIdExecutionIdName User or system provided value for the resource.
   * @param {string} nodeExecutionIdNodeId
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listTaskExecutions(
    nodeExecutionIdExecutionIdProject: string,
    nodeExecutionIdExecutionIdDomain: string,
    nodeExecutionIdExecutionIdName: string,
    nodeExecutionIdNodeId: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listTaskExecutions(
      nodeExecutionIdExecutionIdProject,
      nodeExecutionIdExecutionIdDomain,
      nodeExecutionIdExecutionIdName,
      nodeExecutionIdNodeId,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of task objects.
   * @param {string} project Name of the project that contains the identifiers. +required
   * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {string} [filters] Indicates a list of filters passed as string. +optional.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listTaskIds(
    project: string,
    domain: string,
    limit?: number,
    token?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    filters?: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listTaskIds(
      project,
      domain,
      limit,
      token,
      sortByKey,
      sortByDirection,
      filters,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listTasks(
    idProject: string,
    idDomain: string,
    idName: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listTasks(
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listTasks2(
    idProject: string,
    idDomain: string,
    idName?: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listTasks2(
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of workflow objects.
   * @param {string} project Name of the project that contains the identifiers. +required
   * @param {string} domain Name of the domain the identifiers belongs to within the project. +required
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {string} [filters] Indicates a list of filters passed as string. +optional.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listWorkflowIds(
    project: string,
    domain: string,
    limit?: number,
    token?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    filters?: string,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listWorkflowIds(
      project,
      domain,
      limit,
      token,
      sortByKey,
      sortByDirection,
      filters,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listWorkflows(
    idProject: string,
    idDomain: string,
    idName: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listWorkflows(
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} [idName] User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
   * @param {number} [limit] Indicates the number of resources to be returned. +required.
   * @param {string} [token] In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
   * @param {string} [filters] Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
   * @param {string} [sortByKey] Indicates an attribute to sort the response values. +required.
   * @param {'DESCENDING' | 'ASCENDING'} [sortByDirection] Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public listWorkflows2(
    idProject: string,
    idDomain: string,
    idName?: string,
    limit?: number,
    token?: string,
    filters?: string,
    sortByKey?: string,
    sortByDirection?: "DESCENDING" | "ASCENDING",
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).listWorkflows2(
      idProject,
      idDomain,
      idName,
      limit,
      token,
      filters,
      sortByKey,
      sortByDirection,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Recreates a previously-run workflow execution that will only start executing from the last known failure point. In Recover mode, users cannot change any input parameters or update the version of the execution. This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures, downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again. See :ref:`ref_flyteidl.admin.ExecutionRecoverRequest` for more details.
   * @param {AdminExecutionRecoverRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public recoverExecution(body: AdminExecutionRecoverRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).recoverExecution(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Registers a :ref:`ref_flyteidl.admin.Project` with the Flyte deployment.
   * @param {AdminProjectRegisterRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public registerProject(body: AdminProjectRegisterRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).registerProject(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Triggers the creation of an identical :ref:`ref_flyteidl.admin.Execution`
   * @param {AdminExecutionRelaunchRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public relaunchExecution(body: AdminExecutionRelaunchRequest, options?: any) {
    return AdminServiceApiFp(this.configuration).relaunchExecution(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Terminates an in-progress :ref:`ref_flyteidl.admin.Execution`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User or system provided value for the resource.
   * @param {AdminExecutionTerminateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public terminateExecution(
    idProject: string,
    idDomain: string,
    idName: string,
    body: AdminExecutionTerminateRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).terminateExecution(
      idProject,
      idDomain,
      idName,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update execution belonging to project domain :ref:`ref_flyteidl.admin.Execution`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User or system provided value for the resource.
   * @param {AdminExecutionUpdateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public updateExecution(
    idProject: string,
    idDomain: string,
    idName: string,
    body: AdminExecutionUpdateRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).updateExecution(
      idProject,
      idDomain,
      idName,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Updates the status of a registered :ref:`ref_flyteidl.admin.LaunchPlan`.
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource.
   * @param {string} idVersion Specific version of the resource.
   * @param {AdminLaunchPlanUpdateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public updateLaunchPlan(
    idProject: string,
    idDomain: string,
    idName: string,
    idVersion: string,
    body: AdminLaunchPlanUpdateRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).updateLaunchPlan(
      idProject,
      idDomain,
      idName,
      idVersion,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Updates a :ref:`ref_flyteidl.admin.NamedEntity` object.
   * @param {'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'} resourceType Resource type of the metadata to update +required
   * @param {string} idProject Name of the project the resource belongs to.
   * @param {string} idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
   * @param {string} idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
   * @param {AdminNamedEntityUpdateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public updateNamedEntity(
    resourceType:
      | "UNSPECIFIED"
      | "TASK"
      | "WORKFLOW"
      | "LAUNCH_PLAN"
      | "DATASET",
    idProject: string,
    idDomain: string,
    idName: string,
    body: AdminNamedEntityUpdateRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).updateNamedEntity(
      resourceType,
      idProject,
      idDomain,
      idName,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Updates an existing :ref:`ref_flyteidl.admin.Project`  flyteidl.admin.Project should be passed but the domains property should be empty; it will be ignored in the handler as domains cannot be updated via this API.
   * @param {string} id Globally unique project name.
   * @param {AdminProject} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public updateProject(id: string, body: AdminProject, options?: any) {
    return AdminServiceApiFp(this.configuration).updateProject(
      id,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` at the project level
   * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
   * @param {AdminProjectAttributesUpdateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public updateProjectAttributes(
    attributesProject: string,
    body: AdminProjectAttributesUpdateRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).updateProjectAttributes(
      attributesProject,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
   * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
   * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
   * @param {AdminProjectDomainAttributesUpdateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public updateProjectDomainAttributes(
    attributesProject: string,
    attributesDomain: string,
    body: AdminProjectDomainAttributesUpdateRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).updateProjectDomainAttributes(
      attributesProject,
      attributesDomain,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
   * @param {string} attributesProject Unique project id for which this set of attributes will be applied.
   * @param {string} attributesDomain Unique domain id for which this set of attributes will be applied.
   * @param {string} attributesWorkflow Workflow name for which this set of attributes will be applied.
   * @param {AdminWorkflowAttributesUpdateRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminServiceApi
   */
  public updateWorkflowAttributes(
    attributesProject: string,
    attributesDomain: string,
    attributesWorkflow: string,
    body: AdminWorkflowAttributesUpdateRequest,
    options?: any
  ) {
    return AdminServiceApiFp(this.configuration).updateWorkflowAttributes(
      attributesProject,
      attributesDomain,
      attributesWorkflow,
      body,
      options
    )(this.fetch, this.basePath);
  }
}
